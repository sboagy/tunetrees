/**
 * AUTO-GENERATED FILE â€” DO NOT EDIT.
 *
 * Source: Postgres catalogs (schema: public)
 * Generated by: oosync/src/codegen-schema.ts
 */

import {
  boolean,
  integer,
  jsonb,
  pgTable,
  real,
  text,
} from "drizzle-orm/pg-core";

export const dailyPracticeQueue = pgTable("daily_practice_queue", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userRef: text("user_ref").notNull(),
  playlistRef: text("playlist_ref").notNull(),
  mode: text("mode"),
  queueDate: text("queue_date"),
  windowStartUtc: text("window_start_utc").notNull(),
  windowEndUtc: text("window_end_utc").notNull(),
  tuneRef: text("tune_ref").notNull(),
  bucket: integer("bucket").notNull(),
  orderIndex: integer("order_index").notNull(),
  snapshotCoalescedTs: text("snapshot_coalesced_ts").notNull(),
  scheduledSnapshot: text("scheduled_snapshot"),
  latestDueSnapshot: text("latest_due_snapshot"),
  acceptableDelinquencyWindowSnapshot: integer(
    "acceptable_delinquency_window_snapshot"
  ),
  tzOffsetMinutesSnapshot: integer("tz_offset_minutes_snapshot"),
  generatedAt: text("generated_at").notNull(),
  completedAt: text("completed_at"),
  exposuresRequired: integer("exposures_required"),
  exposuresCompleted: integer("exposures_completed").default(0),
  outcome: text("outcome"),
  active: boolean("active").notNull().default(1),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const genre = pgTable("genre", {
  id: text("id").notNull().primaryKey(),
  name: text("name"),
  region: text("region"),
  description: text("description"),
});

export const genreTuneType = pgTable("genre_tune_type", {
  genreId: text("genre_id").notNull(),
  tuneTypeId: text("tune_type_id").notNull(),
});

export const instrument = pgTable("instrument", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  privateToUser: text("private_to_user"),
  instrument: text("instrument"),
  description: text("description"),
  genreDefault: text("genre_default"),
  deleted: boolean("deleted").notNull().default(0),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const note = pgTable("note", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userRef: text("user_ref"),
  tuneRef: text("tune_ref").notNull(),
  playlistRef: text("playlist_ref"),
  createdDate: text("created_date"),
  noteText: text("note_text"),
  public: boolean("public").notNull().default(0),
  favorite: boolean("favorite"),
  deleted: boolean("deleted").notNull().default(0),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
  displayOrder: integer("display_order").notNull().default(0),
});

export const playlist = pgTable("playlist", {
  playlistId: text("playlist_id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userRef: text("user_ref").notNull(),
  name: text("name"),
  instrumentRef: text("instrument_ref"),
  genreDefault: text("genre_default"),
  srAlgType: text("sr_alg_type"),
  deleted: boolean("deleted").notNull().default(0),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const playlistTune = pgTable("playlist_tune", {
  playlistRef: text("playlist_ref").notNull(),
  tuneRef: text("tune_ref").notNull(),
  current: text("current"),
  learned: text("learned"),
  scheduled: text("scheduled"),
  goal: text("goal").default("recall"),
  deleted: boolean("deleted").notNull().default(0),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const plugin = pgTable("plugin", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userRef: text("user_ref").notNull(),
  name: text("name").notNull(),
  description: text("description"),
  script: text("script").notNull(),
  capabilities: text("capabilities").notNull(),
  isPublic: boolean("is_public").notNull().default(0),
  enabled: boolean("enabled").notNull().default(1),
  version: integer("version").notNull().default(1),
  deleted: boolean("deleted").notNull().default(0),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
  goals: text("goals").notNull().default("[]"),
});

export const practiceRecord = pgTable("practice_record", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  playlistRef: text("playlist_ref").notNull(),
  tuneRef: text("tune_ref").notNull(),
  practiced: text("practiced"),
  quality: integer("quality"),
  easiness: real("easiness"),
  difficulty: real("difficulty"),
  stability: real("stability"),
  interval: integer("interval"),
  step: integer("step"),
  repetitions: integer("repetitions"),
  lapses: integer("lapses"),
  elapsedDays: integer("elapsed_days"),
  state: integer("state"),
  due: text("due"),
  backupPracticed: text("backup_practiced"),
  goal: text("goal").default("recall"),
  technique: text("technique"),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const prefsSchedulingOptions = pgTable("prefs_scheduling_options", {
  userId: text("user_id").notNull().primaryKey(),
  acceptableDelinquencyWindow: integer("acceptable_delinquency_window")
    .notNull()
    .default(21),
  minReviewsPerDay: integer("min_reviews_per_day"),
  maxReviewsPerDay: integer("max_reviews_per_day"),
  daysPerWeek: integer("days_per_week"),
  weeklyRules: text("weekly_rules"),
  exceptions: text("exceptions"),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
  autoScheduleNew: boolean("auto_schedule_new").notNull().default(1),
});

export const prefsSpacedRepetition = pgTable("prefs_spaced_repetition", {
  userId: text("user_id").notNull(),
  algType: text("alg_type").notNull(),
  fsrsWeights: text("fsrs_weights"),
  requestRetention: real("request_retention"),
  maximumInterval: integer("maximum_interval"),
  learningSteps: text("learning_steps"),
  relearningSteps: text("relearning_steps"),
  enableFuzzing: boolean("enable_fuzzing"),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const reference = pgTable("reference", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  url: text("url").notNull(),
  refType: text("ref_type"),
  tuneRef: text("tune_ref").notNull(),
  userRef: text("user_ref"),
  comment: text("comment"),
  title: text("title"),
  public: boolean("public"),
  favorite: boolean("favorite"),
  deleted: boolean("deleted").notNull().default(0),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
  displayOrder: integer("display_order").notNull().default(0),
});

export const syncChangeLog = pgTable("sync_change_log", {
  tableName: text("table_name").notNull().primaryKey(),
  changedAt: text("changed_at").notNull(),
});

export const tabGroupMainState = pgTable("tab_group_main_state", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userId: text("user_id").notNull(),
  whichTab: text("which_tab").default("practice"),
  playlistId: text("playlist_id"),
  tabSpec: text("tab_spec"),
  practiceShowSubmitted: integer("practice_show_submitted").default(0),
  practiceModeFlashcard: integer("practice_mode_flashcard").default(0),
  sidebarDockPosition: text("sidebar_dock_position").default("left"),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const tableState = pgTable("table_state", {
  userId: text("user_id").notNull(),
  screenSize: text("screen_size").notNull(),
  purpose: text("purpose").notNull(),
  playlistId: text("playlist_id").notNull(),
  settings: text("settings"),
  currentTune: text("current_tune"),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const tableTransientData = pgTable("table_transient_data", {
  userId: text("user_id").notNull(),
  tuneId: text("tune_id").notNull(),
  playlistId: text("playlist_id").notNull(),
  purpose: text("purpose"),
  notePrivate: text("note_private"),
  notePublic: text("note_public"),
  recallEval: text("recall_eval"),
  practiced: text("practiced"),
  quality: integer("quality"),
  easiness: real("easiness"),
  difficulty: real("difficulty"),
  interval: integer("interval"),
  step: integer("step"),
  repetitions: integer("repetitions"),
  due: text("due"),
  backupPracticed: text("backup_practiced"),
  goal: text("goal"),
  technique: text("technique"),
  stability: real("stability"),
  state: integer("state").default(2),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const tag = pgTable("tag", {
  tagId: text("tag_id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userRef: text("user_ref").notNull(),
  tuneRef: text("tune_ref").notNull(),
  tagText: text("tag_text").notNull(),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const tune = pgTable("tune", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  idForeign: text("id_foreign"),
  primaryOrigin: text("primary_origin").default("irishtune.info"),
  title: text("title"),
  type: text("type"),
  structure: text("structure"),
  mode: text("mode"),
  incipit: text("incipit"),
  genre: text("genre"),
  privateFor: text("private_for"),
  deleted: boolean("deleted").notNull().default(0),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
  composer: text("composer"),
  artist: text("artist"),
  releaseYear: integer("release_year"),
});

export const tuneOverride = pgTable("tune_override", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  tuneRef: text("tune_ref").notNull(),
  userRef: text("user_ref").notNull(),
  title: text("title"),
  type: text("type"),
  structure: text("structure"),
  genre: text("genre"),
  mode: text("mode"),
  incipit: text("incipit"),
  deleted: boolean("deleted").notNull().default(0),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
  composer: text("composer"),
  artist: text("artist"),
  releaseYear: integer("release_year"),
  idForeign: text("id_foreign"),
});

export const tuneType = pgTable("tune_type", {
  id: text("id").notNull().primaryKey(),
  name: text("name"),
  rhythm: text("rhythm"),
  description: text("description"),
});

export const userGenreSelection = pgTable("user_genre_selection", {
  userId: text("user_id").notNull(),
  genreId: text("genre_id").notNull(),
  createdAt: text("created_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  syncVersion: integer("sync_version").notNull().default(1),
  deviceId: text("device_id"),
});

export const userProfile = pgTable("user_profile", {
  supabaseUserId: text("supabase_user_id").notNull().primaryKey(),
  name: text("name"),
  email: text("email"),
  srAlgType: text("sr_alg_type"),
  phone: text("phone"),
  phoneVerified: text("phone_verified"),
  acceptableDelinquencyWindow: integer("acceptable_delinquency_window").default(
    21
  ),
  avatarUrl: text("avatar_url"),
  deleted: boolean("deleted").notNull().default(0),
  syncVersion: integer("sync_version").notNull().default(1),
  lastModifiedAt: text("last_modified_at")
    .notNull()
    .$defaultFn(() => new Date().toISOString()),
  deviceId: text("device_id"),
});

export const tables = {
  daily_practice_queue: dailyPracticeQueue,
  genre: genre,
  genre_tune_type: genreTuneType,
  instrument: instrument,
  note: note,
  playlist: playlist,
  playlist_tune: playlistTune,
  plugin: plugin,
  practice_record: practiceRecord,
  prefs_scheduling_options: prefsSchedulingOptions,
  prefs_spaced_repetition: prefsSpacedRepetition,
  reference: reference,
  sync_change_log: syncChangeLog,
  tab_group_main_state: tabGroupMainState,
  table_state: tableState,
  table_transient_data: tableTransientData,
  tag: tag,
  tune: tune,
  tune_override: tuneOverride,
  tune_type: tuneType,
  user_genre_selection: userGenreSelection,
  user_profile: userProfile,
} as const;
