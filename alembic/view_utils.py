"""
View management utilities for Alembic migrations.

This module provides helper functions for managing database views in migrations,
since views can't be auto-generated by Alembic due to NullType columns.
"""

from typing import Dict

from alembic import op
import sqlite3
import os
from sqlalchemy import text


def get_view_definitions(db_path: str) -> Dict[str, str]:
    """Extract view definitions from a SQLite database."""
    views: Dict[str, str] = {}
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Get all views and their SQL definitions
        cursor.execute("""
            SELECT name, sql
            FROM sqlite_master
            WHERE type='view'
            AND name NOT LIKE 'sqlite_%'
            ORDER BY name
        """)

        for name, sql in cursor.fetchall():
            if sql:  # Some views might have NULL sql
                views[name] = sql

        conn.close()
    except Exception as e:
        print(f"Warning: Could not extract views from {db_path}: {e}")

    return views


def create_views_from_target_db() -> None:
    """Create views based on the target database schema (tunetrees_test_clean.sqlite3)."""
    # Look for the target database in the project root
    target_db = "tunetrees_test_clean.sqlite3"
    if not os.path.exists(target_db):
        print(f"Warning: Target database {target_db} not found, using hardcoded views")
        create_views_hardcoded()
        return

    views = get_view_definitions(target_db)

    if not views:
        print("Warning: No views found in target database, using hardcoded views")
        create_views_hardcoded()
        return

    print(f"Creating {len(views)} views from target database...")
    for view_name, view_sql in views.items():
        print(f"  - Creating view: {view_name}")
        op.execute(view_sql)


def create_views_hardcoded() -> None:
    """Create views using hardcoded SQL (fallback method)."""
    print("Creating views using hardcoded definitions...")

    # View: view_playlist_joined
    op.execute("""
        CREATE VIEW view_playlist_joined AS
        SELECT
            p.playlist_id,
            p.user_ref,
            p.deleted AS playlist_deleted,
            p.instrument_ref,
            i.private_to_user,
            i.instrument,
            i.description,
            i.genre_default,
            i.deleted AS instrument_deleted
        FROM
            playlist p
            JOIN instrument i ON p.instrument_ref = i.id
    """)

    # View: practice_list_joined
    op.execute("""
        CREATE VIEW practice_list_joined as
        SELECT
            tune.id AS id,
            COALESCE(tune_override.title, tune.title) AS title,
            COALESCE(tune_override.type, tune.type) AS type,
            COALESCE(tune_override.structure, tune.structure) AS structure,
            COALESCE(tune_override.mode, tune.mode) AS mode,
            COALESCE(tune_override.incipit, tune.incipit) AS incipit,
            COALESCE(tune_override.genre, tune.genre) AS genre,
            tune.deleted,
            tune.private_for,
            playlist_tune.learned,
            playlist_tune.goal,
            practice_record.practiced AS latest_practiced,
            practice_record.quality AS latest_quality,
            practice_record.easiness AS latest_easiness,
            practice_record.difficulty AS latest_difficulty,
            practice_record.interval AS latest_interval,
            practice_record.step AS latest_step,
            practice_record.repetitions AS latest_repetitions,
            practice_record.review_date AS latest_review_date,
            practice_record.technique AS latest_technique,
            (
                SELECT
                    group_concat (tag.tag_text, ' ')
                FROM
                    tag
                WHERE
                    tag.tune_ref = tune.id
                    AND tag.user_ref = playlist.user_ref
            ) AS tags,
            playlist_tune.playlist_ref,
            playlist.user_ref,
            playlist_tune.deleted as playlist_deleted,
            (
                SELECT
                    group_concat (note.note_text, ' ')
                FROM
                    note
                WHERE
                    note.tune_ref = tune.id
                    AND note.user_ref = playlist.user_ref
            ) AS notes,
            (
                SELECT
                    ref.url
                FROM
                    reference ref
                WHERE
                    ref.tune_ref = tune.id
                    AND ref.user_ref = playlist.user_ref
                    AND ref.favorite = 1
                LIMIT
                    1
            ) AS favorite_url,
            CASE
                WHEN tune_override.user_ref = playlist.user_ref THEN 1
                ELSE 0
            END AS has_override
        FROM
            tune
            LEFT JOIN playlist_tune ON playlist_tune.tune_ref = tune.id
            LEFT JOIN playlist ON playlist.playlist_id = playlist_tune.playlist_ref
            LEFT JOIN tune_override ON tune_override.tune_ref = tune.id
            LEFT JOIN (
                SELECT
                    pr.*
                FROM practice_record pr
                INNER JOIN (
                    SELECT
                        tune_ref,
                        playlist_ref,
                        MAX(id) as max_id
                    FROM practice_record
                    GROUP BY tune_ref, playlist_ref
                ) latest ON pr.tune_ref = latest.tune_ref
                    AND pr.playlist_ref = latest.playlist_ref
                    AND pr.id = latest.max_id
            ) practice_record ON practice_record.tune_ref = tune.id
            AND practice_record.playlist_ref = playlist_tune.playlist_ref
            LEFT JOIN tag ON tag.tune_ref = COALESCE(tune_override.id, tune.id)
        WHERE
            (
                tune_override.user_ref IS NULL
                OR tune_override.user_ref = playlist.user_ref
            )
    """)

    # View: practice_list_staged
    op.execute("""
        CREATE VIEW practice_list_staged as
        SELECT
            tune.id AS id,
            COALESCE(tune_override.title, tune.title) AS title,
            COALESCE(tune_override.type, tune.type) AS type,
            COALESCE(tune_override.structure, tune.structure) AS structure,
            COALESCE(tune_override.mode, tune.mode) AS mode,
            COALESCE(tune_override.incipit, tune.incipit) AS incipit,
            COALESCE(tune_override.genre, tune.genre) AS genre,
            tune.private_for,
            tune.deleted,
            playlist_tune.learned,
            playlist_tune.goal,
            playlist.user_ref AS user_ref,
            playlist.playlist_id AS playlist_id,
            instrument.instrument AS instrument,
            playlist_tune.deleted as playlist_deleted,
            practice_record.practiced AS latest_practiced,
            practice_record.quality AS latest_quality,
            practice_record.easiness AS latest_easiness,
            practice_record.difficulty AS latest_difficulty,
            practice_record.interval AS latest_interval,
            practice_record.step AS latest_step,
            practice_record.repetitions AS latest_repetitions,
            practice_record.review_date AS latest_review_date,
            practice_record.backup_practiced AS latest_backup_practiced,
            practice_record.technique AS latest_technique,
            (
                SELECT
                    group_concat (tag.tag_text, ' ')
                FROM
                    tag
                WHERE
                    tag.tune_ref = tune.id
                    AND tag.user_ref = playlist.user_ref
            ) AS tags,
            td.purpose AS purpose,
            td.note_private AS note_private,
            td.note_public AS note_public,
            td.recall_eval AS recall_eval,
            (
                SELECT
                    group_concat (note.note_text, ' ')
                FROM
                    note
                WHERE
                    note.tune_ref = tune.id
                    AND note.user_ref = playlist.user_ref
            ) AS notes,
            (
                SELECT
                    ref.url
                FROM
                    reference ref
                WHERE
                    ref.tune_ref = tune.id
                    AND ref.user_ref = playlist.user_ref
                    AND ref.favorite = 1
                LIMIT
                    1
            ) AS favorite_url,
            CASE
                WHEN tune_override.user_ref = playlist.user_ref THEN 1
                ELSE 0
            END AS has_override
        FROM
            tune
            LEFT JOIN playlist_tune ON playlist_tune.tune_ref = tune.id
            LEFT JOIN playlist ON playlist.playlist_id = playlist_tune.playlist_ref
            LEFT JOIN tune_override ON tune_override.tune_ref = tune.id
            LEFT JOIN instrument ON instrument.id = playlist.instrument_ref
            LEFT JOIN practice_record ON practice_record.tune_ref = tune.id
            AND practice_record.playlist_ref = playlist_tune.playlist_ref
            LEFT JOIN tag ON tag.tune_ref = tune.id
            LEFT JOIN table_transient_data td ON td.tune_id = tune.id
            AND td.playlist_id = playlist_tune.playlist_ref
        WHERE
            (
                tune_override.user_ref IS NULL
                OR tune_override.user_ref = playlist.user_ref
            )
    """)


def create_views() -> None:
    """Create all application views - tries dynamic first, falls back to hardcoded."""
    create_views_from_target_db()


def drop_views() -> None:
    """Drop all application views."""
    # Get current views from the database being migrated
    try:
        result = op.get_bind().execute(
            text("""
            SELECT name FROM sqlite_master
            WHERE type='view' AND name NOT LIKE 'sqlite_%'
            ORDER BY name DESC
        """)
        )

        views_to_drop = [row[0] for row in result]

        for view_name in views_to_drop:
            print(f"  - Dropping view: {view_name}")
            op.execute(f"DROP VIEW IF EXISTS {view_name}")
    except Exception as e:
        print(f"Warning: Could not drop views dynamically: {e}")
        # Fallback to hardcoded view names
        op.execute("DROP VIEW IF EXISTS practice_list_staged")
        op.execute("DROP VIEW IF EXISTS practice_list_joined")
        op.execute("DROP VIEW IF EXISTS view_playlist_joined")


def recreate_views() -> None:
    """Drop and recreate all views (useful when dependencies change)."""
    drop_views()
    create_views()
