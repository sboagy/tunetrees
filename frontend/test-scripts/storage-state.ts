import { frontendDirPath } from "@/test-scripts/paths-for-tests";
import * as fs from "node:fs";
import path from "node:path";

// Internal mutable types to allow url-based cookies during CI adaptation
type IMutableCookie = {
  name: string;
  value: string;
  domain?: string;
  url?: string;
  path: string;
  expires: number;
  httpOnly: boolean;
  secure: boolean;
  sameSite: "Strict" | "Lax" | "None";
};

type IMutableStorageState = {
  cookies: IMutableCookie[];
  origins: Array<{
    origin: string;
    localStorage: Array<{
      name: string;
      value: string;
    }>;
  }>;
};

type StorageStateType = string;

export function getStorageState(storageStateVarName: string): StorageStateType {
  let storageStateContent = "";
  const storageStateVarValue = process.env[storageStateVarName];
  // console.log(
  //   "===> storage-state.ts:31 ~ storageStateVarValue",
  //   storageStateVarValue,
  // );
  if (!storageStateVarValue) {
    throw new Error(`Environment variable ${storageStateVarName} is not set`);
  }

  // Debugging: Log the first few characters of the environment variable
  const isFileInput = storageStateVarValue.startsWith(
    "test-scripts/storageState",
  );
  if (isFileInput) {
    // console.log("===> storage-state.ts:42 ~ processing storage state case 1");
    const storageStatePath = path.resolve(
      frontendDirPath,
      storageStateVarValue,
    );
    storageStateContent = fs.readFileSync(storageStatePath, "utf8");
    // Debugging: Log the first few characters of the file content
  } else {
    // console.log("===> storage-state.ts:50 ~  processing storage state case 2");
    // Assume it's coming from a secret and the value is already JSON
    storageStateContent = Buffer.from(storageStateVarValue, "base64").toString(
      "utf8",
    );

    // console.log(
    //   `Storage state environment variable first 100 (${storageStateVarName}): ${storageStateContent.slice(0, 100)}...`,
    // );
    // console.log(
    //   `Storage state environment variable last 100 (${storageStateVarName}) end: ${storageStateContent.slice(-100)}...`,
    // );
  }
  const storageStateParsed: IMutableStorageState | string =
    JSON.parse(storageStateContent);

  // Always ensure cookies have valid schema for Playwright (path or url must be present)
  if (typeof storageStateParsed !== "string") {
    for (const c of storageStateParsed.cookies ?? []) {
      // Ensure every cookie has at least a path property for Playwright validation
      c.path = c.path || "/";
    }
  }

  // Adapt storage state to match the environment base URL so cookies/origins align.
  // Only do this in CI or when explicitly forced to avoid unexpected local changes.
  const shouldAdapt =
    (process.env.CI === "true" ||
      process.env.PLAYWRIGHT_FORCE_STORAGE_ADAPT === "true") &&
    // Important: if the storage state comes from a file generated by Playwright
    // in this same environment (our login pre-step), do NOT adapt it.
    !isFileInput;
  if (shouldAdapt && typeof storageStateParsed !== "string") {
    try {
      const envBase =
        process.env.PLAYWRIGHT_BASE_URL ||
        process.env.NEXT_BASE_URL ||
        process.env.AUTH_URL ||
        "http://localhost:3000";
      const parsed = new URL(envBase);
      const targetOrigin = parsed.origin; // e.g., http://localhost:3000 or https://localhost:3000
      const targetHost = parsed.hostname; // e.g., localhost
      const isHttps = parsed.protocol === "https:";

      // Rewrite cookies: domain localhost -> 127.0.0.1, secure -> false
      // Also adjust callback-url cookie value if it encodes https://localhost:3000
      for (const c of storageStateParsed.cookies ?? []) {
        // Normalize host for CI http server
        if (c.domain === "localhost") {
          c.domain = targetHost;
        }
        // Playwright enforces cookie prefix rules:
        // - __Host- requires Secure + Path=/ + no Domain (HTTPS only)
        // - __Secure- requires Secure (HTTPS only)
        // Since CI uses HTTP, drop these prefixes and set secure=false
        if (c.name.startsWith("__Host-")) {
          // Example: __Host-authjs.csrf-token -> authjs.csrf-token
          c.name = c.name.replace("__Host-", "");
          // Ensure cookie path is root when __Host- prefix was used
          c.path = c.path || "/";
        }
        if (c.name.startsWith("__Secure-")) {
          c.name = c.name.replace("__Secure-", "");
        }
        // Set secure according to protocol (HTTPS true, HTTP false)
        c.secure = isHttps;

        // Some tools export fractional expires; coerce to integer seconds
        if (typeof c.expires === "number" && c.expires > 0) {
          c.expires = Math.floor(c.expires);
        }

        // Update callback-url cookie value to current base origin when present
        if (
          c.name === "authjs.callback-url" &&
          c.value.includes("https%3A%2F%2Flocalhost%3A3000")
        ) {
          c.value = c.value.replace(
            "https%3A%2F%2Flocalhost%3A3000",
            encodeURIComponent(targetOrigin),
          );
        }

        // Back-compat: if someone persisted the old __Secure-authjs.callback-url name
        if (
          c.name === "authjs.callback-url" &&
          c.value.includes("https://localhost:3000")
        ) {
          c.value = c.value.replace("https://localhost:3000", targetOrigin);
        }

        // Ensure sameSite is compatible with non-secure (None requires Secure)
        if (c.sameSite === "None" && !c.secure) {
          c.sameSite = "Lax";
        }
        // Ensure each cookie has either `url` or (`domain` and `path`).
        // For CI, use url-based cookies to avoid Domain/IP scoping issues
        c.url = targetOrigin;
        // Remove domain when using url to avoid conflicts
        if ("domain" in c) {
          delete c.domain;
        }
        // Always ensure path is set as backup
        c.path = c.path || "/";
      }

      // Rewrite origins array from https://localhost:3000 -> http://127.0.0.1:3000
      for (const o of storageStateParsed.origins ?? []) {
        o.origin = targetOrigin;
      }
    } catch (error) {
      console.warn(
        "storage-state.ts: CI adaptation skipped due to error:",
        error,
      );
    }
  }
  // Always return a file path to satisfy Playwright type expectations for storageState
  // Write the (possibly adapted) storage state JSON to a generated file
  const outDir = path.resolve(
    frontendDirPath,
    "test-scripts/.generated-storage-states",
  );
  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true });
  }
  const safeName = `${storageStateVarName.toLowerCase()}-${process.env.CI === "true" ? "ci" : "local"}.json`;
  const outPath = path.resolve(outDir, safeName);
  const toWrite =
    typeof storageStateParsed === "string"
      ? storageStateParsed
      : JSON.stringify(storageStateParsed, null, 2);

  // Debug: Log the first cookie to see its structure
  if (process.env.CI === "true" && typeof storageStateParsed !== "string") {
    const firstCookie = storageStateParsed.cookies?.[0];
    console.log(
      "===> First cookie after adaptation:",
      JSON.stringify(firstCookie, null, 2),
    );
  }

  fs.writeFileSync(outPath, toWrite, "utf8");
  return outPath;
}
