import datetime
from enum import Enum
from typing import Literal, Optional

from pydantic import BaseModel, ConfigDict, Field, field_validator

# This file is largely generated by AI models, to reflect the SQLAlchemy models.
# It is dissapointing that SQLAlchemy models can't be directly used as Pydantic models,
# or that that FastAPI doesn't support SQLAlchemy models directly.
#
# Each Pydantic model has a variant that is partial, which is used for partial updates.
# Future versions of Python or type checkers might introduce features that allow for
# more dynamic type hints, potentially making a create_partial_model approach directly usable,
# or it will support something like `Partial[T]`, similar to of Partial<T> in TypeScript,
# to allow for partial updates.
# There are also some dynamic class creation methods that could be used to generate the
# partial models, but that's has issues with tooling, etc.
# So, fo now, we define the partial models statically (using AI to generate because I'm lazy).
#
# BUT, SQLModel supports both the latest SQLAlchemy (2.0.35 as of November 23, 2024)
# and Pydantic 2.8.2.  Unfortunately, sqlacodegen_v2 isn't quite there yet with generating
# latest SQLModel code.  So, we're stuck with this for now, until sqlacodegen_v2 catches up.


class AlgTypeEnum(str, Enum):
    SM2 = "SM2"
    FSRS = "FSRS"


AlgorithmType = AlgTypeEnum


class PracticeGoalEnum(str, Enum):
    """Practice goals as defined in Issue #205"""

    initial_learn = "initial_learn"
    recall = "recall"
    fluency = "fluency"
    session_ready = "session_ready"
    performance_polish = "performance_polish"


class PracticeTechniqueEnum(str, Enum):
    """Practice techniques for different goals"""

    # For recall goal
    fsrs = "fsrs"
    sm2 = "sm2"
    # For other goals (to be expanded)
    daily_practice = "daily_practice"
    motor_skills = "motor_skills"
    metronome = "metronome"
    # Open for future expansion
    custom = "custom"


class WhichTabEnum(str, Enum):
    scheduled = "scheduled"
    repertoire = "repertoire"
    catalog = "catalog"
    analysis = "analysis"


class ScreenSizeEnum(str, Enum):
    small = "small"
    full = "full"


class PurposeEnum(str, Enum):
    practice = "practice"
    repertoire = "repertoire"
    all = "catalog"
    analysis = "analysis"


class PlaylistTuneModel(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    playlist_ref: int
    tune_ref: int  # Changed from str to int
    current: str
    learned: str
    deleted: Optional[bool]
    goal: Optional[str] = "recall"  # Default to recall, stored as TEXT in database
    scheduled: Optional[str] = None  # Next review date for this tune in this playlist


class PlaylistTuneModelPartial(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    playlist_ref: Optional[int] = None
    tune_ref: Optional[int] = None
    current: Optional[str] = None
    learned: Optional[str] = None
    deleted: Optional[bool] = None
    goal: Optional[str] = None
    scheduled: Optional[str] = None


class TuneModel(BaseModel):
    id: int
    type: Optional[str]
    structure: Optional[str]
    title: Optional[str]
    mode: Optional[str]
    incipit: Optional[str]
    genre: Optional[str]
    private_for: Optional[int]
    deleted: Optional[bool]

    model_config = ConfigDict(from_attributes=True)


class TuneModelPartial(BaseModel):
    id: Optional[int] = None
    type: Optional[str] = None
    structure: Optional[str] = None
    title: Optional[str] = None
    mode: Optional[str] = None
    incipit: Optional[str] = None
    genre: Optional[str] = None
    private_for: Optional[int] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class TuneOverrideModel(BaseModel):
    id: int
    tune_ref: int
    user_ref: int
    title: Optional[str]
    type: Optional[str]
    structure: Optional[str]
    genre: Optional[str]
    mode: Optional[str]
    incipit: Optional[str]
    deleted: Optional[bool] = Field(default=False)

    model_config = ConfigDict(from_attributes=True)


class TuneOverrideModelPartial(BaseModel):
    id: Optional[int] = None
    tune_ref: Optional[int] = None
    user_ref: Optional[int] = None
    title: Optional[str] = None
    type: Optional[str] = None
    structure: Optional[str] = None
    genre: Optional[str] = None
    mode: Optional[str] = None
    incipit: Optional[str] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class TuneModelCreate(BaseModel):
    title: str
    type: str
    structure: str
    mode: str
    incipit: str
    genre: str
    private_for: Optional[int] = None
    deleted: Optional[bool] = False

    model_config = ConfigDict(from_attributes=True)


class VerificationTokenModel(BaseModel):
    identifier: str
    token: str
    expires: str

    model_config = ConfigDict(from_attributes=True)


class VerificationTokenModelPartial(BaseModel):
    identifier: Optional[str] = None
    token: Optional[str] = None
    expires: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class AccountType(str, Enum):
    oauth = "oauth"
    oidc = "oidc"
    email = "email"
    credentials = "credentials"


class AccountModel(BaseModel):
    user_id: str
    provider_account_id: str
    provider: str
    type: AccountType
    access_token: Optional[str] = None
    token_type: Optional[str] = None
    id_token: Optional[str] = None
    scope: Optional[str] = None
    expires_at: Optional[int] = None
    session_state: Optional[str]
    refresh_token: Optional[str]

    model_config = ConfigDict(from_attributes=True)


class AccountModelPartial(BaseModel):
    user_id: Optional[int] = None
    provider_account_id: Optional[str] = None
    provider: Optional[str] = None
    type: Optional[str] = None
    access_token: Optional[str] = None
    id_token: Optional[str] = None
    refresh_token: Optional[str] = None
    scope: Optional[str] = None
    expires_at: Optional[int] = None
    session_state: Optional[str] = None
    token_type: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class ExternalRefModel(BaseModel):
    id: int
    url: str
    tune_ref: int
    ref_type: Optional[str]

    model_config = ConfigDict(from_attributes=True)


class ExternalRefModelPartial(BaseModel):
    id: Optional[int] = None
    url: Optional[str] = None
    tune_ref: Optional[int] = None
    ref_type: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class PlaylistModel(BaseModel):
    playlist_id: int
    user_ref: Optional[int]
    instrument_ref: Optional[int]
    deleted: Optional[bool]
    sr_alg_type: Optional[str] = Field(default=None)

    model_config = ConfigDict(from_attributes=True)


class PlaylistModelPartial(BaseModel):
    playlist_id: Optional[int] = None
    user_ref: Optional[int] = None
    instrument_ref: Optional[int] = None
    deleted: Optional[bool] = None
    sr_alg_type: Optional[str] = Field(default=None)

    model_config = ConfigDict(from_attributes=True)


class InstrumentModel(BaseModel):
    id: int
    private_to_user: Optional[int]
    instrument: str
    description: Optional[str]
    genre_default: Optional[str]
    deleted: Optional[bool]

    model_config = ConfigDict(from_attributes=True)


class InstrumentModelPartial(BaseModel):
    id: Optional[int] = None
    private_to_user: Optional[int] = None
    instrument: Optional[str] = None
    description: Optional[str] = None
    genre_default: Optional[str] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class PrefsSpacedRepetitionModel(BaseModel):
    alg_type: AlgTypeEnum
    user_id: int
    fsrs_weights: Optional[str]
    request_retention: Optional[float]
    maximum_interval: Optional[int]
    learning_steps: Optional[str]
    relearning_steps: Optional[str]
    enable_fuzzing: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class PrefsSpacedRepetitionModelPartial(BaseModel):
    alg_type: Optional[AlgTypeEnum] = None
    user_id: Optional[int] = None
    fsrs_weights: Optional[str] = None
    request_retention: Optional[float] = None
    maximum_interval: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class SessionModel(BaseModel):
    expires: Optional[str]
    session_token: str
    user_id: Optional[int]

    model_config = ConfigDict(from_attributes=True)


class SessionModelPartial(BaseModel):
    expires: Optional[str] = None
    session_token: Optional[str] = None
    user_id: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class TabGroupMainStateModel(BaseModel):
    id: int
    user_id: int
    which_tab: WhichTabEnum
    playlist_id: int
    tab_spec: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class TabGroupMainStateModelPartial(BaseModel):
    id: Optional[int] = None
    user_id: Optional[int] = None
    which_tab: Optional[WhichTabEnum] = None
    playlist_id: Optional[int] = None
    tab_spec: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class TableStateModel(BaseModel):
    user_id: int
    screen_size: Literal["small", "full"]
    purpose: Literal["practice", "repertoire", "catalog", "analysis"]
    settings: str
    current_tune: Optional[int] = None
    playlist_id: int

    @field_validator("user_id")
    def user_id_must_be_positive(cls, value: int) -> int:
        if value <= 0:
            raise ValueError("user_id must be greater than zero")
        return value

    @field_validator("playlist_id")
    def playlist_id_must_be_positive(cls, value: int) -> int:
        if value <= 0:
            raise ValueError("playlist_id must be greater than zero")
        return value

    model_config = ConfigDict(from_attributes=True)


class TableStateModelPartial(BaseModel):
    user_id: Optional[int] = None
    screen_size: Optional[ScreenSizeEnum] = None
    purpose: Optional[PurposeEnum] = None
    settings: Optional[str] = None
    current_tune: Optional[int] = None
    playlist_id: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class UserAnnotationSetModel(BaseModel):
    tune_ref: int
    note_private: Optional[str]
    note_public: Optional[str]
    tags: Optional[str]
    user_ref: int
    deleted: Optional[bool]

    model_config = ConfigDict(from_attributes=True)


class UserAnnotationSetModelPartial(BaseModel):
    tune_ref: Optional[int] = None
    note_private: Optional[str] = None
    note_public: Optional[str] = None
    tags: Optional[str] = None
    user_ref: Optional[int] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class PracticeRecordModel(BaseModel):
    playlist_ref: Optional[int]
    tune_ref: Optional[int]
    practiced: Optional[str]
    quality: Optional[int]
    id: int
    easiness: Optional[float]
    interval: Optional[int]
    repetitions: Optional[int]
    review_date: Optional[
        str
    ]  # NEXT due snapshot (immutable) written at evaluation time
    backup_practiced: Optional[str]
    stability: Optional[float]
    elapsed_days: Optional[int]
    lapses: Optional[int]
    state: Optional[int]
    difficulty: Optional[float]
    step: Optional[int]
    goal: Optional[str] = "recall"
    technique: Optional[str]

    model_config = ConfigDict(from_attributes=True)


class PracticeRecordModelPartial(BaseModel):
    playlist_ref: Optional[int] = None
    tune_ref: Optional[int] = None
    practiced: Optional[str] = None
    quality: Optional[int] = None
    id: Optional[int] = None
    easiness: Optional[float] = None
    interval: Optional[int] = None
    repetitions: Optional[int] = None
    review_date: Optional[str] = None  # NEXT due snapshot (immutable)
    backup_practiced: Optional[str] = None
    stability: Optional[float] = None
    elapsed_days: Optional[int] = None
    lapses: Optional[int] = None
    state: Optional[int] = None
    difficulty: Optional[float] = None
    step: Optional[int] = None
    goal: Optional[str] = "recall"
    technique: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class TableTransientDataModel(BaseModel):
    user_id: int
    tune_id: int
    playlist_id: int
    purpose: PurposeEnum
    note_private: Optional[str]
    note_public: Optional[str]
    recall_eval: Optional[str]
    # Staged practice outcome fields
    practiced: Optional[str] = None
    quality: Optional[int] = None
    easiness: Optional[float] = None
    difficulty: Optional[float] = None
    interval: Optional[int] = None
    step: Optional[int] = None
    repetitions: Optional[int] = None
    review_date: Optional[str] = None
    backup_practiced: Optional[str] = None
    goal: Optional[str] = None
    technique: Optional[str] = None
    stability: Optional[float] = None

    model_config = ConfigDict(from_attributes=True)


class TableTransientDataModelPartial(BaseModel):
    user_id: Optional[int] = None
    tune_id: Optional[int] = None
    playlist_id: Optional[int] = None
    purpose: Optional[PurposeEnum] = None
    note_private: Optional[str] = None
    note_public: Optional[str] = None
    recall_eval: Optional[str] = None
    practiced: Optional[str] = None
    quality: Optional[int] = None
    easiness: Optional[float] = None
    difficulty: Optional[float] = None
    interval: Optional[int] = None
    step: Optional[int] = None
    repetitions: Optional[int] = None
    review_date: Optional[str] = None
    backup_practiced: Optional[str] = None
    goal: Optional[str] = None
    technique: Optional[str] = None
    stability: Optional[float] = None

    model_config = ConfigDict(from_attributes=True)


class NoteModel(BaseModel):
    id: int
    user_ref: int
    tune_ref: int
    playlist_ref: Optional[int]
    created_date: Optional[str]
    note_text: Optional[str]
    public: Optional[bool]
    favorite: Optional[int]

    model_config = ConfigDict(from_attributes=True)


class NoteModelPartial(BaseModel):
    id: Optional[int] = None
    user_ref: Optional[int] = None
    tune_ref: Optional[int] = None
    playlist_ref: Optional[int] = None
    created_date: Optional[str] = None
    note_text: Optional[str] = None
    public: Optional[bool] = None
    favorite: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class NoteModelCreate(BaseModel):
    user_ref: int
    tune_ref: int
    playlist_ref: Optional[int] = None
    created_date: Optional[str] = None
    note_text: Optional[str] = None
    public: Optional[bool] = False
    favorite: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class ReferenceModel(BaseModel):
    tune_ref: int
    user_ref: int
    public: int | None
    id: int
    url: str
    ref_type: str
    favorite: int | None
    comment: str | None
    title: str | None
    deleted: Optional[bool]

    model_config = ConfigDict(from_attributes=True)


class ReferenceModelPartial(BaseModel):
    tune_ref: Optional[int] = None
    user_ref: Optional[int] = None
    public: Optional[int] = None
    id: Optional[int] = None
    url: Optional[str] = None
    ref_type: Optional[str] = None
    favorite: Optional[int] = None
    comment: Optional[str] = None
    title: Optional[str] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class ReferenceModelCreate(BaseModel):
    tune_ref: int
    user_ref: int
    public: int | None
    url: str
    ref_type: str
    favorite: int | None
    comment: str | None
    title: str | None


class PlaylistTuneJoinedModel(BaseModel):
    id: Optional[int] = None
    user_ref: Optional[int] = None
    playlist_ref: Optional[int] = None
    title: Optional[str] = None
    type: Optional[str] = None
    structure: Optional[str] = None
    mode: Optional[str] = None
    incipit: Optional[str] = None
    genre: Optional[str] = None
    private_for: Optional[int] = None
    deleted: Optional[bool] = None
    learned: Optional[str] = None
    goal: Optional[str] = None
    scheduled: Optional[str] = (
        None  # Transient manual override of next due (cleared on evaluation)
    )
    latest_practiced: Optional[str] = None
    latest_quality: Optional[int] = None
    latest_easiness: Optional[float] = None
    latest_difficulty: Optional[float] = None
    latest_interval: Optional[int] = None
    latest_step: Optional[int] = None
    latest_repetitions: Optional[int] = None
    latest_review_date: Optional[str] = None
    latest_technique: Optional[str] = None
    latest_goal: Optional[str] = None
    tags: Optional[str] = None
    recall_eval: Optional[str] = None
    notes: Optional[str] = None
    favorite_url: Optional[str] = None
    playlist_deleted: Optional[bool] = None
    has_override: Optional[bool] = None
    bucket: Optional[int] = (
        None  # Daily practice classification (1=due today,2=recently lapsed,3=backfill)
    )

    model_config = ConfigDict(from_attributes=True)


class PracticeListStagedModel(BaseModel):
    id: Optional[int] = None
    title: Optional[str] = None
    type: Optional[str] = None
    structure: Optional[str] = None
    mode: Optional[str] = None
    incipit: Optional[str] = None
    genre: Optional[str] = None
    private_for: Optional[int] = None
    deleted: Optional[bool] = None
    learned: Optional[str] = None
    goal: Optional[str] = None
    scheduled: Optional[str] = None  # Transient manual override (may be cleared)
    user_ref: Optional[int] = None
    playlist_id: Optional[int] = None
    instrument: Optional[str] = None
    playlist_deleted: Optional[bool] = None
    latest_practiced: Optional[str] = None
    latest_quality: Optional[int] = None
    latest_easiness: Optional[float] = None
    latest_difficulty: Optional[float] = None
    latest_interval: Optional[int] = None
    latest_step: Optional[int] = None
    latest_repetitions: Optional[int] = None
    latest_review_date: Optional[str] = (
        None  # Canonical next due snapshot from last PracticeRecord
    )
    latest_backup_practiced: Optional[str] = None
    latest_technique: Optional[str] = None
    latest_goal: Optional[str] = None
    tags: Optional[str] = None
    purpose: Optional[str] = None
    note_private: Optional[str] = None
    note_public: Optional[str] = None
    recall_eval: Optional[str] = None
    notes: Optional[str] = None
    favorite_url: Optional[str] = None
    has_override: Optional[bool] = None
    has_staged: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class ResponseStatusModel(BaseModel):
    status: str
    message: Optional[str] = None


class ColumnSort(BaseModel):
    desc: bool
    id: str


class GenreModel(BaseModel):
    id: str
    name: str
    description: str | None = None
    region: str | None = None

    model_config = ConfigDict(from_attributes=True)


class GenreModelCreate(BaseModel):
    name: str
    description: str | None = None
    region: str | None = None


class GenreModelPartial(BaseModel):
    name: str | None = None
    description: str | None = None
    region: str | None = None


class ViewPlaylistJoinedModel(BaseModel):
    playlist_id: int
    user_ref: int
    playlist_deleted: bool
    instrument_ref: int
    private_to_user: Optional[int]
    instrument: str
    description: Optional[str]
    genre_default: Optional[str]
    instrument_deleted: bool

    model_config = ConfigDict(from_attributes=True)


class UserModel(BaseModel):
    id: Optional[int] = Field(
        description="This will be assigned and will be ignored for create or update",
        default=None,
    )
    name: Optional[str] = Field(
        description="For now assume this is the user name.  It's exact meaning is a little ambigious at the moment",
        default=None,
    )
    email: Optional[str]
    email_verified: Optional[datetime.datetime] = Field(
        default=None, alias="email_verified"
    )
    image: Optional[str] = Field(default=None, alias="image")
    hash: Optional[str] = Field(default=None, alias="hash")
    sr_alg_type: Optional[str] = Field(default="FSRS")
    phone: Optional[str] = Field(default=None, alias="phone")
    phone_verified: Optional[datetime.datetime] = Field(
        default=None, alias="phone_verified"
    )
    acceptable_delinquency_window: Optional[int] = Field(
        default=21, alias="acceptable_delinquency_window"
    )

    model_config = ConfigDict(from_attributes=True)


class UserModelPartial(BaseModel):
    id: Optional[int] = Field(
        description="This will be assigned and will be ignored for create or update",
        default=None,
    )
    name: Optional[str] = Field(
        description="For now assume this is the user name.  It's exact meaning is a little ambigious at the moment",
        default=None,
    )
    email: Optional[str] = Field(default=None)
    email_verified: Optional[datetime.datetime] = Field(
        default=None, alias="email_verified"
    )
    image: Optional[str] = Field(default=None, alias="image")
    hash: Optional[str] = Field(default=None, alias="hash")
    sr_alg_type: Optional[str] = Field(default="FSRS")
    phone: Optional[str] = Field(default=None, alias="phone")
    phone_verified: Optional[datetime.datetime] = Field(
        default=None, alias="phone_verified"
    )
    acceptable_delinquency_window: Optional[int] = Field(
        default=21, alias="acceptable_delinquency_window"
    )

    model_config = ConfigDict(from_attributes=True)


class PrefsSchedulingOptionsModel(BaseModel):
    user_id: int
    acceptable_delinquency_window: Optional[int] = Field(default=21)
    min_reviews_per_day: Optional[int] = None
    max_reviews_per_day: Optional[int] = None
    days_per_week: Optional[int] = None
    weekly_rules: Optional[str] = None  # JSON string
    exceptions: Optional[str] = None  # JSON string

    @field_validator("acceptable_delinquency_window")
    def validate_adw(cls, v: Optional[int]) -> Optional[int]:
        if v is not None and (v < 0 or v > 365):
            raise ValueError("acceptable_delinquency_window must be between 0 and 365")
        return v

    @field_validator("min_reviews_per_day", "max_reviews_per_day")
    def validate_reviews(cls, v: Optional[int]) -> Optional[int]:
        if v is not None and (v < 0 or v > 10000):
            raise ValueError("reviews per day must be between 0 and 10000")
        return v

    @field_validator("days_per_week")
    def validate_days_per_week(cls, v: Optional[int]) -> Optional[int]:
        if v is not None and (v < 0 or v > 7):
            raise ValueError("days_per_week must be between 0 and 7")
        return v

    model_config = ConfigDict(from_attributes=True)


class PrefsSchedulingOptionsModelPartial(BaseModel):
    user_id: Optional[int] = None
    acceptable_delinquency_window: Optional[int] = None
    min_reviews_per_day: Optional[int] = None
    max_reviews_per_day: Optional[int] = None
    days_per_week: Optional[int] = None
    weekly_rules: Optional[str] = None  # JSON string
    exceptions: Optional[str] = None  # JSON string

    model_config = ConfigDict(from_attributes=True)


# {
#     "expires": "Tue Sep 03 2024 23:45:08 GMT-0400 (Eastern Daylight Time)",
#     "sessionToken": "098af529-f6dd-42c8-b7ea-7d79f5bf582f",
#     "userId": "19"
# }


class TokenModel(BaseModel):
    identifier: str
    token: str
    expires: datetime.date


class SessionAndUserModel(BaseModel):
    session: SessionModel
    user: UserModel


class VerificationTokenParamsModel(BaseModel):
    identifier: str
    token: str


class TuneTypeModel(BaseModel):
    id: str
    name: Optional[str] = None
    rhythm: Optional[str] = None
    description: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class TuneTypeModelPartial(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    rhythm: Optional[str] = None
    description: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class GenreTuneTypeModel(BaseModel):
    genre_id: int
    tune_type_id: int

    model_config = ConfigDict(from_attributes=True)


class GenreTuneTypeModelPartial(BaseModel):
    genre_id: Optional[int] = None
    tune_type_id: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class DailyPracticeQueueModel(BaseModel):
    """Snapshot of a tune selected for a user's daily (or rolling) practice window.

    Fields ending with `_snapshot` capture the scheduling state at generation time so later
    mutations to underlying scheduling data (e.g., new reviews) don't retroactively change
    the frozen queue ordering. `bucket` + `order_index` deterministically order the queue.
    `completed_at` is null until the user practices the tune within the window.
    """

    id: int
    user_ref: int
    playlist_ref: int
    mode: Optional[str] = None  # e.g., 'per_day' or 'rolling'
    queue_date: Optional[str] = None  # For per_day mode (local date as string)
    window_start_utc: str
    window_end_utc: str
    tune_ref: int
    bucket: int  # 1=today due, 2=recently lapsed, 3=backfill (see design #237)
    order_index: int
    snapshot_coalesced_ts: str
    scheduled_snapshot: Optional[str] = None
    latest_review_date_snapshot: Optional[str] = None
    acceptable_delinquency_window_snapshot: Optional[int] = None
    tz_offset_minutes_snapshot: Optional[int] = None
    generated_at: str
    completed_at: Optional[str] = None
    exposures_required: Optional[int] = None
    exposures_completed: Optional[int] = 0
    outcome: Optional[str] = None  # Future: practice outcome summary / qualitative tag
    active: Optional[bool] = True

    model_config = ConfigDict(from_attributes=True)


class DailyPracticeQueueModelPartial(BaseModel):
    id: Optional[int] = None
    user_ref: Optional[int] = None
    playlist_ref: Optional[int] = None
    mode: Optional[str] = None
    queue_date: Optional[str] = None
    window_start_utc: Optional[str] = None
    window_end_utc: Optional[str] = None
    tune_ref: Optional[int] = None
    bucket: Optional[int] = None
    order_index: Optional[int] = None
    snapshot_coalesced_ts: Optional[str] = None
    scheduled_snapshot: Optional[str] = None
    latest_review_date_snapshot: Optional[str] = None
    acceptable_delinquency_window_snapshot: Optional[int] = None
    tz_offset_minutes_snapshot: Optional[int] = None
    generated_at: Optional[str] = None
    completed_at: Optional[str] = None
    exposures_required: Optional[int] = None
    exposures_completed: Optional[int] = None
    outcome: Optional[str] = None
    active: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


# ---------------------------------------------------------------------------
# Composite enriched practice queue entry (queue snapshot + tune metadata)
# ---------------------------------------------------------------------------
class PracticeQueueEntryModel(BaseModel):
    """Enriched practice queue row returned by the practice queue endpoints.

    Combines the frozen daily/rolling queue snapshot fields (prefixed or suffixed
    with *_snapshot) and selected tune metadata joined from the staged overlay
    view (t_practice_list_staged). This avoids persisting duplicate metadata in
    the queue table while still giving the frontend everything it needs to render
    the scheduled practice grid.

    Design notes:
        * favorite_url is sourced dynamically from the staged view (via a JOIN) and
            is intentionally NOT stored in DailyPracticeQueue or PracticeRecord to
            avoid duplication / drift.
        * recall_eval & has_staged surface transient staged review state so the UI
            can reflect pending feedback without re-deriving it.
        * tune_title kept distinct from queue row "title" to avoid clobbering; the
            frontend currently maps tune_title -> title for display.
        * mode_key holds the tune's musical mode (e.g. Dorian) so we don't collide
            with the queue's own "mode" (per_day / rolling etc.).
    """

    # Queue snapshot fields
    id: int
    user_ref: int
    playlist_ref: int
    mode: Optional[str] = None
    queue_date: Optional[str] = None
    window_start_utc: str
    window_end_utc: str
    tune_ref: int
    bucket: Optional[int] = None
    order_index: int
    snapshot_coalesced_ts: str
    scheduled_snapshot: Optional[str] = None
    latest_review_date_snapshot: Optional[str] = None
    acceptable_delinquency_window_snapshot: Optional[int] = None
    tz_offset_minutes_snapshot: Optional[int] = None
    generated_at: str
    completed_at: Optional[str] = None
    exposures_required: Optional[int] = None
    exposures_completed: Optional[int] = None
    outcome: Optional[str] = None
    active: Optional[bool] = None

    # Joined tune metadata (all optional – may be absent if join fails)
    tune_title: Optional[str] = None
    type: Optional[str] = None
    structure: Optional[str] = None
    mode_key: Optional[str] = None
    incipit: Optional[str] = None
    genre: Optional[str] = None
    learned: Optional[str] = None
    goal: Optional[str] = None
    scheduled: Optional[str] = None
    latest_practiced: Optional[str] = None
    latest_quality: Optional[int] = None
    latest_easiness: Optional[float] = None
    latest_difficulty: Optional[float] = None
    latest_interval: Optional[int] = None
    latest_step: Optional[int] = None
    latest_repetitions: Optional[int] = None
    latest_review_date: Optional[str] = None
    latest_goal: Optional[str] = None
    latest_technique: Optional[str] = None
    tags: Optional[str] = None
    playlist_deleted: Optional[bool] = None
    notes: Optional[str] = None
    favorite_url: Optional[str] = None
    has_override: Optional[bool] = None
    deleted: Optional[bool] = None
    private_for: Optional[int] = None
    tune_id: Optional[int] = None
    recall_eval: Optional[str] = None
    has_staged: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True, extra="ignore")
