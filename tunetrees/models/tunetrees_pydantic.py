import datetime
from enum import Enum
from typing import Literal, Optional

from pydantic import BaseModel, ConfigDict, Field, field_validator

# This file is largely generated by AI models, to reflect the SQLAlchemy models.
# It is dissapointing that SQLAlchemy models can't be directly used as Pydantic models,
# or that that FastAPI doesn't support SQLAlchemy models directly.
#
# Each Pydantic model has a variant that is partial, which is used for partial updates.
# Future versions of Python or type checkers might introduce features that allow for
# more dynamic type hints, potentially making a create_partial_model approach directly usable,
# or it will support something like `Partial[T]`, similar to of Partial<T> in TypeScript,
# to allow for partial updates.
# There are also some dynamic class creation methods that could be used to generate the
# partial models, but that's has issues with tooling, etc.
# So, fo now, we define the partial models statically (using AI to generate because I'm lazy).
#
# BUT, SQLModel supports both the latest SQLAlchemy (2.0.35 as of November 23, 2024)
# and Pydantic 2.8.2.  Unfortunately, sqlacodegen_v2 isn't quite there yet with generating
# latest SQLModel code.  So, we're stuck with this for now, until sqlacodegen_v2 catches up.


class AlgTypeEnum(str, Enum):
    SM2 = "SM2"
    FSRS = "FSRS"


AlgorithmType = AlgTypeEnum


class PracticeGoalEnum(str, Enum):
    """Practice goals as defined in Issue #205"""

    initial_learn = "initial_learn"
    recall = "recall"
    fluency = "fluency"
    session_ready = "session_ready"
    performance_polish = "performance_polish"


class PracticeTechniqueEnum(str, Enum):
    """Practice techniques for different goals"""

    # For recall goal
    fsrs = "fsrs"
    sm2 = "sm2"
    # For other goals (to be expanded)
    daily_practice = "daily_practice"
    motor_skills = "motor_skills"
    metronome = "metronome"
    # Open for future expansion
    custom = "custom"


class WhichTabEnum(str, Enum):
    scheduled = "scheduled"
    repertoire = "repertoire"
    catalog = "catalog"
    analysis = "analysis"


class ScreenSizeEnum(str, Enum):
    small = "small"
    full = "full"


class PurposeEnum(str, Enum):
    practice = "practice"
    repertoire = "repertoire"
    all = "catalog"
    analysis = "analysis"


class PlaylistTuneModel(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    playlist_ref: int
    tune_ref: int  # Changed from str to int
    current: str
    learned: str
    deleted: Optional[bool]
    goal: Optional[str] = "recall"  # Default to recall, stored as TEXT in database
    technique: Optional[str] = None  # Open text field as requested in Issue #205


class PlaylistTuneModelPartial(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    playlist_ref: Optional[int] = None
    tune_ref: Optional[int] = None
    current: Optional[str] = None
    learned: Optional[str] = None
    deleted: Optional[bool] = None
    goal: Optional[str] = None
    technique: Optional[str] = None


class TuneModel(BaseModel):
    id: int
    type: Optional[str]
    structure: Optional[str]
    title: Optional[str]
    mode: Optional[str]
    incipit: Optional[str]
    genre: Optional[str]
    private_for: Optional[int]
    deleted: Optional[bool]

    model_config = ConfigDict(from_attributes=True)


class TuneModelPartial(BaseModel):
    id: Optional[int] = None
    type: Optional[str] = None
    structure: Optional[str] = None
    title: Optional[str] = None
    mode: Optional[str] = None
    incipit: Optional[str] = None
    genre: Optional[str] = None
    private_for: Optional[int] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class TuneOverrideModel(BaseModel):
    id: int
    tune_ref: int
    user_ref: int
    title: Optional[str]
    type: Optional[str]
    structure: Optional[str]
    genre: Optional[str]
    mode: Optional[str]
    incipit: Optional[str]
    deleted: Optional[bool] = Field(default=False)

    model_config = ConfigDict(from_attributes=True)


class TuneOverrideModelPartial(BaseModel):
    id: Optional[int] = None
    tune_ref: Optional[int] = None
    user_ref: Optional[int] = None
    title: Optional[str] = None
    type: Optional[str] = None
    structure: Optional[str] = None
    genre: Optional[str] = None
    mode: Optional[str] = None
    incipit: Optional[str] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class TuneModelCreate(BaseModel):
    title: str
    type: str
    structure: str
    mode: str
    incipit: str
    genre: str
    private_for: Optional[int] = None
    deleted: Optional[bool] = False

    model_config = ConfigDict(from_attributes=True)


class VerificationTokenModel(BaseModel):
    identifier: str
    token: str
    expires: str

    model_config = ConfigDict(from_attributes=True)


class VerificationTokenModelPartial(BaseModel):
    identifier: Optional[str] = None
    token: Optional[str] = None
    expires: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class AccountType(str, Enum):
    oauth = "oauth"
    oidc = "oidc"
    email = "email"
    credentials = "credentials"


class AccountModel(BaseModel):
    user_id: str
    provider_account_id: str
    provider: str
    type: AccountType
    access_token: Optional[str] = None
    token_type: Optional[str] = None
    id_token: Optional[str] = None
    scope: Optional[str] = None
    expires_at: Optional[int] = None
    session_state: Optional[str]
    refresh_token: Optional[str]

    model_config = ConfigDict(from_attributes=True)


class AccountModelPartial(BaseModel):
    user_id: Optional[int] = None
    provider_account_id: Optional[str] = None
    provider: Optional[str] = None
    type: Optional[str] = None
    access_token: Optional[str] = None
    id_token: Optional[str] = None
    refresh_token: Optional[str] = None
    scope: Optional[str] = None
    expires_at: Optional[int] = None
    session_state: Optional[str] = None
    token_type: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class ExternalRefModel(BaseModel):
    id: int
    url: str
    tune_ref: int
    ref_type: Optional[str]

    model_config = ConfigDict(from_attributes=True)


class ExternalRefModelPartial(BaseModel):
    id: Optional[int] = None
    url: Optional[str] = None
    tune_ref: Optional[int] = None
    ref_type: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class PlaylistModel(BaseModel):
    playlist_id: int
    user_ref: Optional[int]
    instrument_ref: Optional[int]
    deleted: Optional[bool]
    sr_alg_type: Optional[str] = Field(default=None)

    model_config = ConfigDict(from_attributes=True)


class PlaylistModelPartial(BaseModel):
    playlist_id: Optional[int] = None
    user_ref: Optional[int] = None
    instrument_ref: Optional[int] = None
    deleted: Optional[bool] = None
    sr_alg_type: Optional[str] = Field(default=None)

    model_config = ConfigDict(from_attributes=True)


class InstrumentModel(BaseModel):
    id: int
    private_to_user: Optional[int]
    instrument: str
    description: Optional[str]
    genre_default: Optional[str]
    deleted: Optional[bool]

    model_config = ConfigDict(from_attributes=True)


class InstrumentModelPartial(BaseModel):
    id: Optional[int] = None
    private_to_user: Optional[int] = None
    instrument: Optional[str] = None
    description: Optional[str] = None
    genre_default: Optional[str] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class PrefsSpacedRepetitionModel(BaseModel):
    alg_type: AlgTypeEnum
    user_id: int
    fsrs_weights: Optional[str]
    request_retention: Optional[float]
    maximum_interval: Optional[int]
    learning_steps: Optional[str]
    relearning_steps: Optional[str]
    enable_fuzzing: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class PrefsSpacedRepetitionModelPartial(BaseModel):
    alg_type: Optional[AlgTypeEnum] = None
    user_id: Optional[int] = None
    fsrs_weights: Optional[str] = None
    request_retention: Optional[float] = None
    maximum_interval: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class SessionModel(BaseModel):
    expires: Optional[str]
    session_token: str
    user_id: Optional[int]

    model_config = ConfigDict(from_attributes=True)


class SessionModelPartial(BaseModel):
    expires: Optional[str] = None
    session_token: Optional[str] = None
    user_id: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class TabGroupMainStateModel(BaseModel):
    id: int
    user_id: int
    which_tab: WhichTabEnum
    playlist_id: int
    tab_spec: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class TabGroupMainStateModelPartial(BaseModel):
    id: Optional[int] = None
    user_id: Optional[int] = None
    which_tab: Optional[WhichTabEnum] = None
    playlist_id: Optional[int] = None
    tab_spec: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class TableStateModel(BaseModel):
    user_id: int
    screen_size: Literal["small", "full"]
    purpose: Literal["practice", "repertoire", "catalog", "analysis"]
    settings: str
    current_tune: Optional[int] = None
    playlist_id: int

    @field_validator("user_id")
    def user_id_must_be_positive(cls, value: int) -> int:
        if value <= 0:
            raise ValueError("user_id must be greater than zero")
        return value

    @field_validator("playlist_id")
    def playlist_id_must_be_positive(cls, value: int) -> int:
        if value <= 0:
            raise ValueError("playlist_id must be greater than zero")
        return value

    model_config = ConfigDict(from_attributes=True)


class TableStateModelPartial(BaseModel):
    user_id: Optional[int] = None
    screen_size: Optional[ScreenSizeEnum] = None
    purpose: Optional[PurposeEnum] = None
    settings: Optional[str] = None
    current_tune: Optional[int] = None
    playlist_id: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class UserAnnotationSetModel(BaseModel):
    tune_ref: int
    note_private: Optional[str]
    note_public: Optional[str]
    tags: Optional[str]
    user_ref: int
    deleted: Optional[bool]

    model_config = ConfigDict(from_attributes=True)


class UserAnnotationSetModelPartial(BaseModel):
    tune_ref: Optional[int] = None
    note_private: Optional[str] = None
    note_public: Optional[str] = None
    tags: Optional[str] = None
    user_ref: Optional[int] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class PracticeRecordModel(BaseModel):
    playlist_ref: Optional[int]
    tune_ref: Optional[int]
    practiced: Optional[str]
    quality: Optional[int]
    id: int
    easiness: Optional[float]
    interval: Optional[int]
    repetitions: Optional[int]
    review_date: Optional[str]
    backup_practiced: Optional[str]
    stability: Optional[float]
    elapsed_days: Optional[int]
    lapses: Optional[int]
    state: Optional[int]
    difficulty: Optional[float]
    step: Optional[int]
    goal: Optional[str] = "recall"
    technique: Optional[str]

    model_config = ConfigDict(from_attributes=True)


class PracticeRecordModelPartial(BaseModel):
    playlist_ref: Optional[int] = None
    tune_ref: Optional[int] = None
    practiced: Optional[str] = None
    quality: Optional[int] = None
    id: Optional[int] = None
    easiness: Optional[float] = None
    interval: Optional[int] = None
    repetitions: Optional[int] = None
    review_date: Optional[str] = None
    backup_practiced: Optional[str] = None
    stability: Optional[float] = None
    elapsed_days: Optional[int] = None
    lapses: Optional[int] = None
    state: Optional[int] = None
    difficulty: Optional[float] = None
    step: Optional[int] = None
    goal: Optional[str] = "recall"
    technique: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class TableTransientDataModel(BaseModel):
    user_id: int
    tune_id: int
    playlist_id: int
    purpose: PurposeEnum
    note_private: Optional[str]
    note_public: Optional[str]
    recall_eval: Optional[str]

    model_config = ConfigDict(from_attributes=True)


class TableTransientDataModelPartial(BaseModel):
    user_id: Optional[int] = None
    tune_id: Optional[int] = None
    playlist_id: Optional[int] = None
    purpose: Optional[PurposeEnum] = None
    note_private: Optional[str] = None
    note_public: Optional[str] = None
    recall_eval: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class NoteModel(BaseModel):
    id: int
    user_ref: int
    tune_ref: int
    playlist_ref: Optional[int]
    created_date: Optional[str]
    note_text: Optional[str]
    public: Optional[bool]
    favorite: Optional[int]

    model_config = ConfigDict(from_attributes=True)


class NoteModelPartial(BaseModel):
    id: Optional[int] = None
    user_ref: Optional[int] = None
    tune_ref: Optional[int] = None
    playlist_ref: Optional[int] = None
    created_date: Optional[str] = None
    note_text: Optional[str] = None
    public: Optional[bool] = None
    favorite: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class NoteModelCreate(BaseModel):
    user_ref: int
    tune_ref: int
    playlist_ref: Optional[int] = None
    created_date: Optional[str] = None
    note_text: Optional[str] = None
    public: Optional[bool] = False
    favorite: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


class ReferenceModel(BaseModel):
    tune_ref: int
    user_ref: int
    public: int | None
    id: int
    url: str
    ref_type: str
    favorite: int | None
    comment: str | None
    title: str | None
    deleted: Optional[bool]

    model_config = ConfigDict(from_attributes=True)


class ReferenceModelPartial(BaseModel):
    tune_ref: Optional[int] = None
    user_ref: Optional[int] = None
    public: Optional[int] = None
    id: Optional[int] = None
    url: Optional[str] = None
    ref_type: Optional[str] = None
    favorite: Optional[int] = None
    comment: Optional[str] = None
    title: Optional[str] = None
    deleted: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class ReferenceModelCreate(BaseModel):
    tune_ref: int
    user_ref: int
    public: int | None
    url: str
    ref_type: str
    favorite: int | None
    comment: str | None
    title: str | None


class PlaylistTuneJoinedModel(BaseModel):
    id: Optional[int] = None
    user_ref: Optional[int] = None
    playlist_ref: Optional[int] = None
    title: Optional[str] = None
    type: Optional[str] = None
    structure: Optional[str] = None
    mode: Optional[str] = None
    incipit: Optional[str] = None
    genre: Optional[str] = None
    private_for: Optional[int] = None
    deleted: Optional[bool] = None
    learned: Optional[str] = None
    practiced: Optional[str] = None
    quality: Optional[int] = None
    easiness: Optional[float] = None
    difficulty: Optional[float] = None
    interval: Optional[int] = None
    step: Optional[int] = None
    repetitions: Optional[int] = None
    review_date: Optional[str] = None
    tags: Optional[str] = None
    recall_eval: Optional[str] = None
    notes: Optional[str] = None
    favorite_url: Optional[str] = None
    playlist_deleted: Optional[bool] = None
    has_override: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class PracticeListStagedModel(BaseModel):
    id: Optional[int] = None
    title: Optional[str] = None
    type: Optional[str] = None
    structure: Optional[str] = None
    mode: Optional[str] = None
    incipit: Optional[str] = None
    genre: Optional[str] = None
    private_for: Optional[int] = None
    deleted: Optional[bool] = None
    learned: Optional[str] = None
    user_ref: Optional[int] = None
    playlist_id: Optional[int] = None
    instrument: Optional[str] = None
    playlist_deleted: Optional[bool] = None
    practiced: Optional[str] = None
    quality: Optional[int] = None
    easiness: Optional[float] = None
    difficulty: Optional[float] = None
    interval: Optional[int] = None
    step: Optional[int] = None
    repetitions: Optional[int] = None
    review_date: Optional[str] = None
    backup_practiced: Optional[str] = None
    tags: Optional[str] = None
    purpose: Optional[str] = None
    note_private: Optional[str] = None
    note_public: Optional[str] = None
    recall_eval: Optional[str] = None
    notes: Optional[str] = None
    favorite_url: Optional[str] = None
    has_override: Optional[bool] = None

    model_config = ConfigDict(from_attributes=True)


class ResponseStatusModel(BaseModel):
    status: str
    message: Optional[str] = None


class ColumnSort(BaseModel):
    desc: bool
    id: str


class GenreModel(BaseModel):
    id: str
    name: str
    description: str | None = None
    region: str | None = None

    model_config = ConfigDict(from_attributes=True)


class GenreModelCreate(BaseModel):
    name: str
    description: str | None = None
    region: str | None = None


class GenreModelPartial(BaseModel):
    name: str | None = None
    description: str | None = None
    region: str | None = None


class ViewPlaylistJoinedModel(BaseModel):
    playlist_id: int
    user_ref: int
    playlist_deleted: bool
    instrument_ref: int
    private_to_user: Optional[int]
    instrument: str
    description: Optional[str]
    genre_default: Optional[str]
    instrument_deleted: bool

    model_config = ConfigDict(from_attributes=True)


class UserModel(BaseModel):
    id: Optional[int] = Field(
        description="This will be assigned and will be ignored for create or update",
        default=None,
    )
    name: Optional[str] = Field(
        description="For now assume this is the user name.  It's exact meaning is a little ambigious at the moment",
        default=None,
    )
    email: Optional[str]
    email_verified: Optional[datetime.datetime] = Field(
        default=None, alias="email_verified"
    )
    phone: Optional[str] = Field(default=None)
    phone_verified: Optional[datetime.datetime] = Field(
        default=None, alias="phone_verified"
    )
    image: Optional[str] = Field(default=None, alias="image")
    hash: Optional[str] = Field(default=None, alias="hash")
    sr_alg_type: Optional[str] = Field(default="FSRS")

    model_config = ConfigDict(from_attributes=True)


class UserModelPartial(BaseModel):
    id: Optional[int] = Field(
        description="This will be assigned and will be ignored for create or update",
        default=None,
    )
    name: Optional[str] = Field(
        description="For now assume this is the user name.  It's exact meaning is a little ambigious at the moment",
        default=None,
    )
    email: Optional[str] = Field(default=None)
    email_verified: Optional[datetime.datetime] = Field(
        default=None, alias="email_verified"
    )
    phone: Optional[str] = Field(default=None)
    phone_verified: Optional[datetime.datetime] = Field(
        default=None, alias="phone_verified"
    )
    image: Optional[str] = Field(default=None, alias="image")
    hash: Optional[str] = Field(default=None, alias="hash")
    sr_alg_type: Optional[str] = Field(default="FSRS")

    model_config = ConfigDict(from_attributes=True)


# {
#     "expires": "Tue Sep 03 2024 23:45:08 GMT-0400 (Eastern Daylight Time)",
#     "sessionToken": "098af529-f6dd-42c8-b7ea-7d79f5bf582f",
#     "userId": "19"
# }


class TokenModel(BaseModel):
    identifier: str
    token: str
    expires: datetime.date


class SessionAndUserModel(BaseModel):
    session: SessionModel
    user: UserModel


class VerificationTokenParamsModel(BaseModel):
    identifier: str
    token: str


class AuthenticatorModel(BaseModel):
    credential_id: str = Field(description="Unique identifier for the credential")
    user_id: int = Field(description="User ID this credential belongs to")
    credential_public_key: str = Field(description="Public key for the credential")
    counter: int = Field(description="Counter for replay attack prevention")
    credential_device_type: str = Field(description="Type of device ('singleDevice' or 'multiDevice')")
    credential_backed_up: bool = Field(description="Whether the credential is backed up")
    transports: Optional[str] = Field(default=None, description="Comma-separated list of transports")

    model_config = ConfigDict(from_attributes=True)


class AuthenticatorModelPartial(BaseModel):
    credential_id: Optional[str] = None
    user_id: Optional[int] = None
    credential_public_key: Optional[str] = None
    counter: Optional[int] = None
    credential_device_type: Optional[str] = None
    credential_backed_up: Optional[bool] = None
    transports: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class TuneTypeModel(BaseModel):
    id: str
    name: Optional[str] = None
    rhythm: Optional[str] = None
    description: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class TuneTypeModelPartial(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    rhythm: Optional[str] = None
    description: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class GenreTuneTypeModel(BaseModel):
    genre_id: int
    tune_type_id: int

    model_config = ConfigDict(from_attributes=True)


class GenreTuneTypeModelPartial(BaseModel):
    genre_id: Optional[int] = None
    tune_type_id: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)
