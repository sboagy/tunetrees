import { readFileSync, writeFileSync } from "node:fs";
import path from "node:path";

const COLS = [
  "id",
  "playlist_ref",
  "tune_ref",
  "practiced",
  "quality",
  "easiness",
  "difficulty",
  "stability",
  "interval",
  "step",
  "repetitions",
  "lapses",
  "elapsed_days",
  "state",
  "due",
  "backup_practiced",
  "goal",
  "technique",
  "sync_version",
  "last_modified_at",
  "device_id",
] as const;

type ColName = (typeof COLS)[number];

const NUMERIC_COLS: ReadonlySet<ColName> = new Set([
  "quality",
  "easiness",
  "difficulty",
  "stability",
  "interval",
  "step",
  "repetitions",
  "lapses",
  "elapsed_days",
  "state",
  "sync_version",
]);

function usage(): never {
  // eslint-disable-next-line no-console
  console.error(
    "Usage: tsx scripts/generate-practice-records-upsert-sql.ts <input.csv> <output.sql>"
  );
  process.exit(2);
}

function parseCsvLine(line: string): string[] {
  const fields: string[] = [];
  let current = "";
  let inQuotes = false;

  for (let i = 0; i < line.length; i += 1) {
    const ch = line[i];

    if (inQuotes) {
      if (ch === '"') {
        const next = line[i + 1];
        if (next === '"') {
          current += '"';
          i += 1;
        } else {
          inQuotes = false;
        }
      } else {
        current += ch;
      }
      continue;
    }

    if (ch === ",") {
      fields.push(current);
      current = "";
      continue;
    }

    if (ch === '"') {
      inQuotes = true;
      continue;
    }

    current += ch;
  }

  fields.push(current);
  return fields;
}

function isNullToken(value: string): boolean {
  const v = value.trim();
  return v === "" || v.toUpperCase() === "NULL";
}

function sqlEscapeText(value: string): string {
  return value.replace(/'/g, "''");
}

function toSqlLiteral(col: ColName, raw: string): string {
  if (isNullToken(raw)) return "NULL";

  const value = raw.trim();

  if (NUMERIC_COLS.has(col)) {
    // Accept integers or decimals.
    if (!/^[-+]?\d+(\.\d+)?$/.test(value)) {
      throw new Error(`Invalid numeric value for ${col}: '${raw}'`);
    }
    return value;
  }

  return `'${sqlEscapeText(value)}'`;
}

function buildUpsertSqlRow(rawFields: string[]): string {
  if (rawFields.length !== COLS.length) {
    throw new Error(
      `Expected ${COLS.length} columns, got ${rawFields.length}: ${rawFields.join(",")}`
    );
  }

  // Provide safe defaults for NOT NULL columns and common nullable defaults.
  // Some CSV exports omit trailing fields, producing empty strings.
  const practicedRaw = rawFields[3] ?? "";
  const nowIso = new Date().toISOString();

  const coerced = [...rawFields];
  if (isNullToken(coerced[18] ?? "")) {
    // sync_version is NOT NULL in Postgres
    coerced[18] = "1";
  }
  if (isNullToken(coerced[19] ?? "")) {
    // last_modified_at is NOT NULL in Postgres
    coerced[19] = !isNullToken(practicedRaw) ? practicedRaw : nowIso;
  }
  if (isNullToken(coerced[16] ?? "")) {
    // goal has a default but inserting NULL bypasses it
    coerced[16] = "recall";
  }

  const literals = coerced.map((v, idx) => toSqlLiteral(COLS[idx], v));
  return `(${literals.join(", ")})`;
}

function main(): void {
  const inputPath = process.argv[2];
  const outputPath = process.argv[3];
  if (!inputPath || !outputPath) usage();

  const csvPath = path.resolve(process.cwd(), inputPath);
  const outPath = path.resolve(process.cwd(), outputPath);

  const raw = readFileSync(csvPath, "utf-8");
  const lines = raw
    .split(/\r?\n/)
    .map((l) => l.trimEnd())
    .filter((l) => l.length > 0);

  const rows: string[] = [];
  for (const line of lines) {
    const parsed = parseCsvLine(line);
    rows.push(buildUpsertSqlRow(parsed));
  }

  const CHUNK_SIZE = 300;

  const updateCols = COLS.filter((c) => c !== "id");
  const updateSet = updateCols
    .map((c) => `${c} = EXCLUDED.${c}`)
    .join(",\n    ");

  const statements: string[] = [];
  statements.push("BEGIN;");

  for (let i = 0; i < rows.length; i += CHUNK_SIZE) {
    const chunk = rows.slice(i, i + CHUNK_SIZE);

    statements.push(
      `INSERT INTO public.practice_record (\n  ${COLS.join(",\n  ")}\n) VALUES\n  ${chunk.join(",\n  ")}\nON CONFLICT (tune_ref, playlist_ref, practiced) DO UPDATE SET\n    ${updateSet};`
    );
  }

  statements.push("COMMIT;");

  const header = `-- Generated by scripts/generate-practice-records-upsert-sql.ts\n-- Source: ${path.basename(csvPath)}\n-- Rows: ${rows.length}\n\n`;

  writeFileSync(outPath, `${header + statements.join("\n\n")}\n`, "utf-8");

  // eslint-disable-next-line no-console
  console.log(`[practice_record] Wrote ${rows.length} rows to ${outPath}`);
}

main();
