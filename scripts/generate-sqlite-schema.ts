import * as fs from "node:fs";
import * as path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";
import * as ts from "typescript";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const INPUT_FILE = path.join(__dirname, "../drizzle/schema-postgres.ts");
const OUTPUT_FILE = path.join(__dirname, "../drizzle/schema-sqlite.generated.ts");

function parseArgs(argv: string[]): { check: boolean } {
  return { check: argv.includes("--check") };
}

function createHeader(): string {
  return `/**
 * AUTO-GENERATED FILE — DO NOT EDIT.
 *
 * Source: drizzle/schema-postgres.ts
 * Generated by: scripts/generate-sqlite-schema.ts
 */
\n`;
}

function toSnakeCase(value: string): string {
  return value
    .replace(/([a-z0-9])([A-Z])/g, "$1_$2")
    .replace(/__/g, "_")
    .toLowerCase();
}

function getStringLiteral(node: ts.Expression): string | null {
  if (ts.isStringLiteral(node)) return node.text;
  if (ts.isNoSubstitutionTemplateLiteral(node)) return node.text;
  return null;
}

function buildColumnSqlNameMap(columnsArg: ts.Expression): Map<string, string> {
  const map = new Map<string, string>();
  if (!ts.isObjectLiteralExpression(columnsArg)) return map;

  for (const prop of columnsArg.properties) {
    if (!ts.isPropertyAssignment(prop)) continue;
    if (!ts.isIdentifier(prop.name) && !ts.isStringLiteral(prop.name)) continue;
    const propName = ts.isIdentifier(prop.name) ? prop.name.text : prop.name.text;

    // Column definitions are typically like: foo: uuid("foo")...
    const initializer = prop.initializer;
    if (!ts.isCallExpression(initializer)) continue;

    const firstArg = initializer.arguments[0];
    if (!firstArg) continue;
    const sqlName = getStringLiteral(firstArg);
    if (!sqlName) continue;

    map.set(propName, sqlName);
  }

  return map;
}

function isUniqueOnCall(node: ts.Expression): node is ts.CallExpression {
  if (!ts.isCallExpression(node)) return false;
  if (!ts.isPropertyAccessExpression(node.expression)) return false;
  if (node.expression.name.text !== "on") return false;
  const base = node.expression.expression;
  if (!ts.isCallExpression(base)) return false;
  if (!ts.isIdentifier(base.expression)) return false;
  return base.expression.text === "unique";
}

function isCheckCall(node: ts.Expression): boolean {
  return ts.isCallExpression(node) && ts.isIdentifier(node.expression) && node.expression.text === "check";
}

function replaceImports(sf: ts.SourceFile): ts.SourceFile {
  const statements: ts.Statement[] = [];

  for (const stmt of sf.statements) {
    if (!ts.isImportDeclaration(stmt)) {
      statements.push(stmt);
      continue;
    }

    const spec = stmt.moduleSpecifier;
    const moduleName = ts.isStringLiteral(spec) ? spec.text : null;

    // Drop drizzle-orm sql import (only used for check constraints, which we remove)
    if (moduleName === "drizzle-orm") {
      continue;
    }

    // Replace pg-core import with sqlite-core import
    if (moduleName === "drizzle-orm/pg-core") {
      const importClause = ts.factory.createImportClause(
        false,
        undefined,
        ts.factory.createNamedImports([
          ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier("index")),
          ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier("integer")),
          ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier("primaryKey")),
          ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier("real")),
          ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier("sqliteTable")),
          ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier("text")),
          ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier("uniqueIndex")),
        ])
      );

      statements.push(
        ts.factory.createImportDeclaration(
          stmt.modifiers,
          importClause,
          ts.factory.createStringLiteral("drizzle-orm/sqlite-core")
        )
      );
      continue;
    }

    // Swap pgSyncColumns -> sqliteSyncColumns
    if (moduleName === "./sync-columns") {
      if (!stmt.importClause?.namedBindings || !ts.isNamedImports(stmt.importClause.namedBindings)) {
        statements.push(stmt);
        continue;
      }

      const newSpecs: ts.ImportSpecifier[] = [];
      for (const s of stmt.importClause.namedBindings.elements) {
        const imported = s.propertyName ? s.propertyName.text : s.name.text;
        const local = s.name.text;
        if (imported === "pgSyncColumns" && local === "pgSyncColumns") {
          newSpecs.push(
            ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier("sqliteSyncColumns"))
          );
          continue;
        }
        if (imported === "pgSyncColumns") {
          // Preserve aliasing if present.
          newSpecs.push(
            ts.factory.createImportSpecifier(
              false,
              ts.factory.createIdentifier("sqliteSyncColumns"),
              ts.factory.createIdentifier(local)
            )
          );
          continue;
        }
        newSpecs.push(s);
      }

      const importClause = ts.factory.updateImportClause(
        stmt.importClause,
        false,
        stmt.importClause.name,
        ts.factory.createNamedImports(newSpecs)
      );

      statements.push(ts.factory.updateImportDeclaration(stmt, stmt.modifiers, importClause, stmt.moduleSpecifier));
      continue;
    }

    statements.push(stmt);
  }

  return ts.factory.updateSourceFile(sf, statements);
}

function buildUniqueIndexName(params: {
  tableName: string;
  columns: string[];
}): string {
  const parts = [params.tableName, ...params.columns, "unique"];
  return parts.filter(Boolean).join("_");
}

function transformFile(sf: ts.SourceFile): ts.SourceFile {
  // First, replace imports as needed.
  sf = replaceImports(sf);

  // General (context-free) transforms: types, defaults, sync columns, and removing checks.
  const generalTransformer: ts.TransformerFactory<ts.SourceFile> = (ctx) => {
    const v: ts.Visitor = (node) => {
      const visited = ts.visitEachChild(node, v, ctx);

      // Drop check(...) entries from arrays (table config lists)
      if (ts.isArrayLiteralExpression(visited)) {
        const newElements = visited.elements.filter((el) => {
          if (!ts.isCallExpression(el)) return true;
          return !isCheckCall(el);
        });
        if (newElements.length !== visited.elements.length) {
          return ts.factory.updateArrayLiteralExpression(visited, newElements);
        }
      }

      // Convert pgTable(...) -> sqliteTable(...)
      if (ts.isIdentifier(visited) && visited.text === "pgTable") {
        return ts.factory.createIdentifier("sqliteTable");
      }

      // Replace spread ...pgSyncColumns with ...sqliteSyncColumns
      if (ts.isSpreadAssignment(visited) && ts.isIdentifier(visited.expression) && visited.expression.text === "pgSyncColumns") {
        return ts.factory.updateSpreadAssignment(
          visited,
          ts.factory.createIdentifier("sqliteSyncColumns")
        );
      }

      // Convert uuid()/timestamp()/boolean() builders
      if (ts.isCallExpression(visited) && ts.isIdentifier(visited.expression)) {
        const fn = visited.expression.text;
        if (fn === "uuid" || fn === "timestamp") {
          return ts.factory.updateCallExpression(
            visited,
            ts.factory.createIdentifier("text"),
            visited.typeArguments,
            visited.arguments
          );
        }
        if (fn === "boolean") {
          return ts.factory.updateCallExpression(
            visited,
            ts.factory.createIdentifier("integer"),
            visited.typeArguments,
            visited.arguments
          );
        }
      }

      // Convert .default(true/false) -> .default(1/0)
      if (ts.isCallExpression(visited) && ts.isPropertyAccessExpression(visited.expression)) {
        if (visited.expression.name.text === "default" && visited.arguments.length === 1) {
          const arg = visited.arguments[0];
          if (
            arg &&
            (arg.kind === ts.SyntaxKind.TrueKeyword ||
              arg.kind === ts.SyntaxKind.FalseKeyword)
          ) {
            const intLiteral = ts.factory.createNumericLiteral(
              arg.kind === ts.SyntaxKind.TrueKeyword ? 1 : 0
            );
            return ts.factory.updateCallExpression(visited, visited.expression, visited.typeArguments, [
              intLiteral,
            ]);
          }
        }
      }

      return visited;
    };

    return (sourceFile) => ts.visitNode(sourceFile, v) as ts.SourceFile;
  };

  // Table-aware transforms: unique().on(...) -> uniqueIndex("...").on(...)
  const tableAwareTransformer: ts.TransformerFactory<ts.SourceFile> = (ctx) => {
    const v: ts.Visitor = (node) => {
      if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && node.expression.text === "sqliteTable") {
        const [tableNameExpr, columnsExpr, configExpr] = node.arguments;
        const tableName = tableNameExpr ? getStringLiteral(tableNameExpr) : null;
        const colMap = columnsExpr ? buildColumnSqlNameMap(columnsExpr) : new Map<string, string>();

        if (tableName && configExpr && ts.isArrowFunction(configExpr)) {
          // Visit the config expression with access to tableName + columns map.
          const configVisitor: ts.Visitor = (n) => {
            if (isUniqueOnCall(n)) {
              const args = n.arguments;
              const colSqlNames: string[] = [];
              for (const a of args) {
                // Expected: t.someColumn
                if (!ts.isPropertyAccessExpression(a)) continue;
                const prop = a.name.text;
                colSqlNames.push(colMap.get(prop) ?? toSnakeCase(prop));
              }
              const uniqueName = buildUniqueIndexName({
                tableName,
                columns: colSqlNames,
              });

              const uniqueIndexCall = ts.factory.createCallExpression(
                ts.factory.createIdentifier("uniqueIndex"),
                undefined,
                [ts.factory.createStringLiteral(uniqueName)]
              );

              const onAccess = ts.factory.createPropertyAccessExpression(uniqueIndexCall, "on");

              return ts.factory.updateCallExpression(n, onAccess, n.typeArguments, n.arguments);
            }

            // Strip any remaining check(...) calls inside config
            if (isCheckCall(n)) {
              // Caller should filter arrays, but be safe.
              return ts.factory.createOmittedExpression();
            }

            return ts.visitEachChild(n, configVisitor, ctx);
          };

          const newConfig = ts.visitNode(configExpr, configVisitor);

          return ts.factory.updateCallExpression(node, node.expression, node.typeArguments, [
            tableNameExpr,
            columnsExpr,
            newConfig as ts.Expression,
          ]);
        }

        return ts.visitEachChild(node, v, ctx);
      }

      return ts.visitEachChild(node, v, ctx);
    };

    return (sourceFile) => ts.visitNode(sourceFile, v) as ts.SourceFile;
  };

  const result = ts.transform(sf, [generalTransformer, tableAwareTransformer]);
  const out = result.transformed[0];
  result.dispose();

  return out;
}

function generateSqliteSchemaText(): string {
  if (!fs.existsSync(INPUT_FILE)) {
    throw new Error(`Input file not found: ${INPUT_FILE}`);
  }
  const input = fs.readFileSync(INPUT_FILE, "utf-8");

  const sf = ts.createSourceFile(INPUT_FILE, input, ts.ScriptTarget.ESNext, true, ts.ScriptKind.TS);
  const transformed = transformFile(sf);

  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const printed = printer.printFile(transformed);

  return createHeader() + printed;
}

function main(): void {
  const { check } = parseArgs(process.argv.slice(2));

  const outputText = generateSqliteSchemaText();

  if (check) {
    if (!fs.existsSync(OUTPUT_FILE)) {
      console.error(`❌ Missing generated file: ${OUTPUT_FILE}`);
      process.exit(1);
    }
    const existing = fs.readFileSync(OUTPUT_FILE, "utf-8");
    if (existing !== outputText) {
      console.error("❌ SQLite schema is out of date. Run: npm run schema:sqlite:gen");
      process.exit(1);
    }
    console.log("✅ SQLite schema is up to date.");
    return;
  }

  fs.writeFileSync(OUTPUT_FILE, outputText, "utf-8");
  console.log(`✅ Wrote ${path.relative(process.cwd(), OUTPUT_FILE)}`);
}

main();
