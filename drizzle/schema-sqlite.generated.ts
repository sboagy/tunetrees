/**
 * AUTO-GENERATED FILE â€” DO NOT EDIT.
 *
 * Source: drizzle/schema-postgres.ts
 * Generated by: scripts/generate-sqlite-schema.ts
 */

import { index, integer, primaryKey, real, sqliteTable, text, uniqueIndex } from "drizzle-orm/sqlite-core";
import { generateId } from "../src/lib/utils/uuid";
import { sqliteSyncColumns } from "./sync-columns";
// ============================================================================
// User Profile (replaces legacy "user" table)
// ============================================================================
/**
 * User Profile table
 *
 * Extends Supabase auth.users with app-specific fields.
 * The supabase_user_id is the source of truth (FK to auth.users).
 */
export const userProfile = sqliteTable("user_profile", {
    id: text("id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    supabaseUserId: text("supabase_user_id").notNull().unique(),
    name: text("name"),
    email: text("email"), // Denormalized from auth.users for queries
    avatarUrl: text("avatar_url"), // User avatar image URL (predefined or custom upload)
    srAlgType: text("sr_alg_type"), // 'SM2' | 'FSRS'
    phone: text("phone"),
    phoneVerified: text("phone_verified"),
    acceptableDelinquencyWindow: integer("acceptable_delinquency_window").default(21),
    deleted: integer("deleted").default(0).notNull(),
    // Sync columns
    ...sqliteSyncColumns,
});
// ============================================================================
// Reference Data (no sync columns needed)
// ============================================================================
/**
 * Genre table
 * System reference data for music genres (Irish, Scottish, Old-Time, etc.)
 */
export const genre = sqliteTable("genre", {
    id: text("id").primaryKey(),
    name: text("name"),
    region: text("region"),
    description: text("description"),
});
/**
 * Tune Type table
 * System reference data for tune types (Jig, Reel, Waltz, etc.)
 */
export const tuneType = sqliteTable("tune_type", {
    id: text("id").primaryKey(),
    name: text("name"),
    rhythm: text("rhythm"),
    description: text("description"),
});
/**
 * Genre-Tune Type association table
 * Many-to-many relationship
 */
export const genreTuneType = sqliteTable("genre_tune_type", {
    genreId: text("genre_id")
        .notNull()
        .references(() => genre.id),
    tuneTypeId: text("tune_type_id")
        .notNull()
        .references(() => tuneType.id),
}, (t) => [primaryKey({ columns: [t.genreId, t.tuneTypeId] })]);
// ============================================================================
// Core Music Data (with sync columns)
// ============================================================================
/**
 * Tune table
 *
 * Stores tune metadata (title, type, structure, mode, etc.).
 * Most tunes are public (from TheSession.org, etc.) but users can create private tunes.
 * Private tunes need sync columns for multi-device support.
 */
export const tune = sqliteTable("tune", {
    id: text("id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    composer: text("composer"),
    artist: text("artist"),
    idForeign: text("id_foreign"),
    releaseYear: integer("release_year"),
    primaryOrigin: text("primary_origin").default("irishtune.info"), // Source: 'irishtune.info', 'user_created', etc.
    title: text("title"),
    type: text("type"),
    structure: text("structure"),
    mode: text("mode"),
    incipit: text("incipit"), // ABC notation snippet
    genre: text("genre").references(() => genre.id),
    privateFor: text("private_for").references(() => userProfile.id),
    deleted: integer("deleted").default(0).notNull(),
    // Sync columns (needed for private tunes)
    ...sqliteSyncColumns,
});
/**
 * Tune Override table
 *
 * Allows users to customize tune metadata (title, type, etc.) without modifying the base tune.
 * User-specific overrides need sync columns.
 */
export const tuneOverride = sqliteTable("tune_override", {
    id: text("id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    tuneRef: text("tune_ref")
        .notNull()
        .references(() => tune.id),
    userRef: text("user_ref")
        .notNull()
        .references(() => userProfile.id),
    title: text("title"),
    type: text("type"),
    structure: text("structure"),
    genre: text("genre").references(() => genre.id),
    mode: text("mode"),
    incipit: text("incipit"),
    composer: text("composer"),
    artist: text("artist"),
    idForeign: text("id_foreign"),
    releaseYear: integer("release_year"),
    deleted: integer("deleted").default(0).notNull(),
    // Sync columns
    ...sqliteSyncColumns,
});
/**
 * Instrument table
 *
 * Stores instrument information (name, description, genre default).
 * Users can create custom instruments (privateToUser IS NOT NULL).
 */
export const instrument = sqliteTable("instrument", {
    id: text("id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    privateToUser: text("private_to_user").references(() => userProfile.id),
    instrument: text("instrument"),
    description: text("description"),
    genreDefault: text("genre_default"),
    deleted: integer("deleted").default(0).notNull(),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [
    uniqueIndex("instrument_private_to_user_instrument_unique").on(t.privateToUser, t.instrument),
    index("idx_instrument_instrument").on(t.instrument),
    index("idx_instrument_private_to_user").on(t.privateToUser),
]);
// ============================================================================
// Playlist & Practice Data (with sync columns)
// ============================================================================
/**
 * Playlist table
 *
 * A playlist is a user's collection of tunes for a specific instrument.
 * Each user can have one playlist per instrument.
 */
export const playlist = sqliteTable("playlist", {
    playlistId: text("playlist_id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    userRef: text("user_ref")
        .notNull()
        .references(() => userProfile.id),
    name: text("name"), // Playlist name (e.g., "My Irish Tunes")
    instrumentRef: text("instrument_ref"),
    genreDefault: text("genre_default").references(() => genre.id), // Default genre for this playlist
    srAlgType: text("sr_alg_type"), // 'SM2' | 'FSRS'
    deleted: integer("deleted").default(0).notNull(),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [uniqueIndex("playlist_user_ref_instrument_ref_unique").on(t.userRef, t.instrumentRef)]);
/**
 * Playlist-Tune association table
 *
 * Many-to-many relationship between playlists and tunes.
 * Tracks when a tune was added (current), learned, and scheduled.
 */
export const playlistTune = sqliteTable("playlist_tune", {
    playlistRef: text("playlist_ref")
        .notNull()
        .references(() => playlist.playlistId),
    tuneRef: text("tune_ref")
        .notNull()
        .references(() => tune.id),
    current: text("current"),
    learned: text("learned"),
    scheduled: text("scheduled"),
    goal: text("goal").default("recall"), // 'recall' | 'memorize' | etc.
    deleted: integer("deleted").default(0).notNull(),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [primaryKey({ columns: [t.playlistRef, t.tuneRef] })]);
/**
 * Practice Record table
 *
 * Stores spaced repetition data for each tune in a playlist.
 * One record per practice session (identified by practiced timestamp).
 */
export const practiceRecord = sqliteTable("practice_record", {
    id: text("id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    playlistRef: text("playlist_ref")
        .notNull()
        .references(() => playlist.playlistId),
    tuneRef: text("tune_ref")
        .notNull()
        .references(() => tune.id),
    practiced: text("practiced"),
    quality: integer("quality"), // SM2/FSRS quality rating (0-5)
    easiness: real("easiness"), // SM2 easiness factor
    difficulty: real("difficulty"), // FSRS difficulty
    stability: real("stability"), // FSRS stability
    interval: integer("interval"), // Days until next review
    step: integer("step"), // FSRS step
    repetitions: integer("repetitions"),
    lapses: integer("lapses"),
    elapsedDays: integer("elapsed_days"),
    state: integer("state"), // FSRS state (0=new, 1=learning, 2=review, 3=relearning)
    due: text("due"),
    backupPracticed: text("backup_practiced"),
    goal: text("goal").default("recall"),
    technique: text("technique"),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [
    uniqueIndex("practice_record_tune_ref_playlist_ref_practiced_unique").on(t.tuneRef, t.playlistRef, t.practiced),
    index("idx_practice_record_id").on(t.id.desc()),
    index("idx_practice_record_tune_playlist_practiced").on(t.tuneRef, t.playlistRef, t.practiced.desc()),
    index("idx_practice_record_practiced").on(t.practiced.desc()),
]);
/**
 * Daily Practice Queue table
 *
 * Stores the generated practice queue for each user/playlist/date.
 * Each queue item represents one tune to practice in a specific time window.
 */
export const dailyPracticeQueue = sqliteTable("daily_practice_queue", {
    id: text("id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    userRef: text("user_ref").notNull(),
    playlistRef: text("playlist_ref").notNull(),
    mode: text("mode"),
    queueDate: text("queue_date"),
    windowStartUtc: text("window_start_utc").notNull(),
    windowEndUtc: text("window_end_utc").notNull(),
    tuneRef: text("tune_ref").notNull(),
    bucket: integer("bucket").notNull(), // 0=new, 1=learning, 2=review
    orderIndex: integer("order_index").notNull(),
    snapshotCoalescedTs: text("snapshot_coalesced_ts").notNull(),
    scheduledSnapshot: text("scheduled_snapshot"),
    latestDueSnapshot: text("latest_due_snapshot"),
    acceptableDelinquencyWindowSnapshot: integer("acceptable_delinquency_window_snapshot"),
    tzOffsetMinutesSnapshot: integer("tz_offset_minutes_snapshot"),
    generatedAt: text("generated_at").notNull(),
    completedAt: text("completed_at"),
    exposuresRequired: integer("exposures_required"),
    exposuresCompleted: integer("exposures_completed").default(0),
    outcome: text("outcome"),
    active: integer("active").default(1).notNull(),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [
    uniqueIndex("daily_practice_queue_user_ref_playlist_ref_window_start_utc_tune_ref_unique").on(t.userRef, t.playlistRef, t.windowStartUtc, t.tuneRef),
    index("idx_queue_user_playlist_window").on(t.userRef, t.playlistRef, t.windowStartUtc),
    index("idx_queue_user_playlist_active").on(t.userRef, t.playlistRef, t.active),
    index("idx_queue_user_playlist_bucket").on(t.userRef, t.playlistRef, t.bucket),
    index("idx_queue_generated_at").on(t.generatedAt),
]);
// ============================================================================
// User Content (Notes, References, Tags) - with sync columns
// ============================================================================
/**
 * Note table
 *
 * User-created notes for tunes (can be public or private).
 */
export const note = sqliteTable("note", {
    id: text("id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    userRef: text("user_ref").references(() => userProfile.id),
    tuneRef: text("tune_ref")
        .notNull()
        .references(() => tune.id),
    playlistRef: text("playlist_ref").references(() => playlist.playlistId),
    createdDate: text("created_date"),
    noteText: text("note_text"),
    public: integer("public").default(0).notNull(),
    favorite: integer("favorite"),
    displayOrder: integer("display_order").default(0).notNull(), // For drag ordering
    deleted: integer("deleted").default(0).notNull(),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [
    index("idx_note_tune_playlist").on(t.tuneRef, t.playlistRef),
    index("idx_note_tune_playlist_user_public").on(t.tuneRef, t.playlistRef, t.userRef, t.public),
    index("idx_note_tune_user").on(t.tuneRef, t.userRef)
]);
/**
 * Reference table
 *
 * External links (websites, audio, video) for tunes.
 */
export const reference = sqliteTable("reference", {
    id: text("id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    url: text("url").notNull(),
    refType: text("ref_type"), // 'website' | 'audio' | 'video'
    tuneRef: text("tune_ref")
        .notNull()
        .references(() => tune.id),
    userRef: text("user_ref").references(() => userProfile.id),
    comment: text("comment"),
    title: text("title"),
    public: integer("public"),
    favorite: integer("favorite"),
    displayOrder: integer("display_order").default(0).notNull(), // For drag ordering
    deleted: integer("deleted").default(0).notNull(),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [
    index("idx_reference_tune_public").on(t.tuneRef, t.public),
    index("idx_reference_tune_user_ref").on(t.tuneRef, t.userRef),
    index("idx_reference_user_tune_public").on(t.userRef, t.tuneRef, t.public)
]);
/**
 * Tag table
 *
 * User-created tags for tunes.
 */
export const tag = sqliteTable("tag", {
    tagId: text("tag_id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    userRef: text("user_ref")
        .notNull()
        .references(() => userProfile.id),
    tuneRef: text("tune_ref")
        .notNull()
        .references(() => tune.id),
    tagText: text("tag_text").notNull(),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [
    uniqueIndex("tag_user_ref_tune_ref_tag_text_unique").on(t.userRef, t.tuneRef, t.tagText),
    index("idx_tag_user_ref_tag_text").on(t.userRef, t.tagText),
    index("idx_tag_user_ref_tune_ref").on(t.userRef, t.tuneRef),
]);
// ============================================================================
// Preferences (with sync columns)
// ============================================================================
/**
 * Spaced Repetition Preferences table
 *
 * Per-user, per-algorithm preferences for spaced repetition.
 */
export const prefsSpacedRepetition = sqliteTable("prefs_spaced_repetition", {
    userId: text("user_id")
        .notNull()
        .references(() => userProfile.id),
    algType: text("alg_type").notNull(), // 'SM2' | 'FSRS'
    fsrsWeights: text("fsrs_weights"),
    requestRetention: real("request_retention"),
    maximumInterval: integer("maximum_interval"),
    learningSteps: text("learning_steps"),
    relearningSteps: text("relearning_steps"),
    enableFuzzing: integer("enable_fuzzing"),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [
    primaryKey({ columns: [t.userId, t.algType] })
]);
/**
 * Scheduling Preferences table
 *
 * Per-user scheduling preferences (acceptable delinquency, min/max reviews, etc.).
 */
export const prefsSchedulingOptions = sqliteTable("prefs_scheduling_options", {
    userId: text("user_id")
        .primaryKey()
        .references(() => userProfile.id),
    acceptableDelinquencyWindow: integer("acceptable_delinquency_window")
        .default(21)
        .notNull(),
    minReviewsPerDay: integer("min_reviews_per_day"),
    maxReviewsPerDay: integer("max_reviews_per_day"),
    daysPerWeek: integer("days_per_week"),
    weeklyRules: text("weekly_rules"), // JSON string
    exceptions: text("exceptions"), // JSON string
    // Sync columns
    ...sqliteSyncColumns,
});
// ============================================================================
// UI State (with sync columns)
// ============================================================================
/**
 * Tab Group Main State table
 *
 * Stores the active tab for each user (practice, repertoire, catalog, analysis).
 */
export const tabGroupMainState = sqliteTable("tab_group_main_state", {
    id: text("id")
        .primaryKey()
        .$defaultFn(() => generateId()),
    userId: text("user_id")
        .notNull()
        .references(() => userProfile.id),
    whichTab: text("which_tab").default("practice"),
    playlistId: text("playlist_id"),
    tabSpec: text("tab_spec"),
    practiceShowSubmitted: integer("practice_show_submitted").default(0),
    practiceModeFlashcard: integer("practice_mode_flashcard").default(0),
    sidebarDockPosition: text("sidebar_dock_position").default("left"),
    // Sync columns
    ...sqliteSyncColumns,
}, () => []);
/**
 * Table State table
 *
 * Stores table settings (sort, filter, column visibility) per user/screen size/purpose.
 */
export const tableState = sqliteTable("table_state", {
    userId: text("user_id")
        .notNull()
        .references(() => userProfile.id),
    screenSize: text("screen_size").notNull(),
    purpose: text("purpose").notNull(),
    playlistId: text("playlist_id")
        .notNull()
        .references(() => playlist.playlistId),
    settings: text("settings"),
    currentTune: text("current_tune"),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [
    primaryKey({
        columns: [t.userId, t.screenSize, t.purpose, t.playlistId],
    })
]);
/**
 * Table Transient Data table
 *
 * Temporary data for the practice workflow (staged practice records).
 */
export const tableTransientData = sqliteTable("table_transient_data", {
    userId: text("user_id")
        .notNull()
        .references(() => userProfile.id),
    tuneId: text("tune_id")
        .notNull()
        .references(() => tune.id),
    playlistId: text("playlist_id")
        .notNull()
        .references(() => playlist.playlistId),
    purpose: text("purpose"),
    notePrivate: text("note_private"),
    notePublic: text("note_public"),
    recallEval: text("recall_eval"),
    practiced: text("practiced"),
    quality: integer("quality"),
    easiness: real("easiness"),
    difficulty: real("difficulty"),
    interval: integer("interval"),
    step: integer("step"),
    repetitions: integer("repetitions"),
    due: text("due"),
    backupPracticed: text("backup_practiced"),
    goal: text("goal"),
    technique: text("technique"),
    stability: real("stability"),
    state: integer("state").default(2),
    // Sync columns
    ...sqliteSyncColumns,
}, (t) => [primaryKey({ columns: [t.tuneId, t.userId, t.playlistId] })]);
// ============================================================================
// Schema Exports
// ============================================================================
/**
 * Export all tables for use in Drizzle ORM queries
 */
export const schema = {
    userProfile,
    genre,
    tuneType,
    genreTuneType,
    tune,
    tuneOverride,
    instrument,
    playlist,
    playlistTune,
    practiceRecord,
    dailyPracticeQueue,
    note,
    reference,
    tag,
    prefsSpacedRepetition,
    prefsSchedulingOptions,
    tabGroupMainState,
    tableState,
    tableTransientData,
};
