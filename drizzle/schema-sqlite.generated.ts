/**
 * AUTO-GENERATED FILE â€” DO NOT EDIT.
 *
 * Source: Postgres catalogs (schema: public)
 * Generated by: oosync/src/codegen-schema.ts
 */

import {
  index,
  integer,
  primaryKey,
  real,
  sqliteTable,
  text,
  uniqueIndex,
} from "drizzle-orm/sqlite-core";
import { sqliteSyncColumns } from "./sync-columns";

export const dailyPracticeQueue = sqliteTable(
  "daily_practice_queue",
  {
    id: text("id")
      .notNull()
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userRef: text("user_ref").notNull(),
    playlistRef: text("playlist_ref").notNull(),
    mode: text("mode"),
    queueDate: text("queue_date"),
    windowStartUtc: text("window_start_utc").notNull(),
    windowEndUtc: text("window_end_utc").notNull(),
    tuneRef: text("tune_ref").notNull(),
    bucket: integer("bucket").notNull(),
    orderIndex: integer("order_index").notNull(),
    snapshotCoalescedTs: text("snapshot_coalesced_ts").notNull(),
    scheduledSnapshot: text("scheduled_snapshot"),
    latestDueSnapshot: text("latest_due_snapshot"),
    acceptableDelinquencyWindowSnapshot: integer(
      "acceptable_delinquency_window_snapshot"
    ),
    tzOffsetMinutesSnapshot: integer("tz_offset_minutes_snapshot"),
    generatedAt: text("generated_at").notNull(),
    completedAt: text("completed_at"),
    exposuresRequired: integer("exposures_required"),
    exposuresCompleted: integer("exposures_completed").default(0),
    outcome: text("outcome"),
    active: integer("active").notNull().default(1),
    ...sqliteSyncColumns,
  },
  (t) => [
    uniqueIndex(
      "daily_practice_queue_user_ref_playlist_ref_window_start_utc_key"
    ).on(t.userRef, t.playlistRef, t.windowStartUtc, t.tuneRef),
    index("idx_queue_generated_at").on(t.generatedAt),
    index("idx_queue_user_playlist_active").on(
      t.userRef,
      t.playlistRef,
      t.active
    ),
    index("idx_queue_user_playlist_bucket").on(
      t.userRef,
      t.playlistRef,
      t.bucket
    ),
    index("idx_queue_user_playlist_window").on(
      t.userRef,
      t.playlistRef,
      t.windowStartUtc
    ),
  ]
);

export const genre = sqliteTable("genre", {
  id: text("id").notNull().primaryKey(),
  name: text("name"),
  region: text("region"),
  description: text("description"),
});

export const genreTuneType = sqliteTable(
  "genre_tune_type",
  {
    genreId: text("genre_id")
      .notNull()
      .references(() => genre.id),
    tuneTypeId: text("tune_type_id")
      .notNull()
      .references(() => tuneType.id),
  },
  (t) => [primaryKey({ columns: [t.genreId, t.tuneTypeId] })]
);

export const instrument = sqliteTable(
  "instrument",
  {
    id: text("id")
      .notNull()
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    privateToUser: text("private_to_user").references(() => userProfile.id),
    instrument: text("instrument"),
    description: text("description"),
    genreDefault: text("genre_default"),
    deleted: integer("deleted").notNull().default(0),
    ...sqliteSyncColumns,
  },
  (t) => [
    uniqueIndex("instrument_private_to_user_instrument_key").on(
      t.privateToUser,
      t.instrument
    ),
    index("idx_instrument_instrument").on(t.instrument),
    index("idx_instrument_private_to_user").on(t.privateToUser),
  ]
);

export const note = sqliteTable(
  "note",
  {
    id: text("id")
      .notNull()
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userRef: text("user_ref").references(() => userProfile.id),
    tuneRef: text("tune_ref")
      .notNull()
      .references(() => tune.id),
    playlistRef: text("playlist_ref").references(() => playlist.playlistId),
    createdDate: text("created_date"),
    noteText: text("note_text"),
    public: integer("public").notNull().default(0),
    favorite: integer("favorite"),
    deleted: integer("deleted").notNull().default(0),
    displayOrder: integer("display_order").notNull().default(0),
    ...sqliteSyncColumns,
  },
  (t) => [
    index("idx_note_last_modified_at").on(t.lastModifiedAt),
    index("idx_note_tune_playlist").on(t.tuneRef, t.playlistRef),
    index("idx_note_tune_playlist_user_public").on(
      t.tuneRef,
      t.playlistRef,
      t.userRef,
      t.public
    ),
    index("idx_note_tune_user").on(t.tuneRef, t.userRef),
  ]
);

export const playlist = sqliteTable("playlist", {
  playlistId: text("playlist_id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userRef: text("user_ref")
    .notNull()
    .references(() => userProfile.id),
  name: text("name"),
  instrumentRef: text("instrument_ref"),
  genreDefault: text("genre_default").references(() => genre.id),
  srAlgType: text("sr_alg_type"),
  deleted: integer("deleted").notNull().default(0),
  ...sqliteSyncColumns,
});

export const playlistTune = sqliteTable(
  "playlist_tune",
  {
    playlistRef: text("playlist_ref")
      .notNull()
      .references(() => playlist.playlistId),
    tuneRef: text("tune_ref")
      .notNull()
      .references(() => tune.id),
    current: text("current"),
    learned: text("learned"),
    scheduled: text("scheduled"),
    goal: text("goal").default("recall"),
    deleted: integer("deleted").notNull().default(0),
    ...sqliteSyncColumns,
  },
  (t) => [primaryKey({ columns: [t.playlistRef, t.tuneRef] })]
);

export const plugin = sqliteTable(
  "plugin",
  {
    id: text("id")
      .notNull()
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userRef: text("user_ref").notNull(),
    name: text("name").notNull(),
    description: text("description"),
    script: text("script").notNull(),
    capabilities: text("capabilities").notNull(),
    isPublic: integer("is_public").notNull().default(0),
    enabled: integer("enabled").notNull().default(1),
    version: integer("version").notNull().default(1),
    deleted: integer("deleted").notNull().default(0),
    goals: text("goals").notNull().default("[]"),
    ...sqliteSyncColumns,
  },
  (t) => [
    index("idx_plugin_public").on(t.isPublic),
    index("idx_plugin_user_ref").on(t.userRef),
  ]
);

export const practiceRecord = sqliteTable(
  "practice_record",
  {
    id: text("id")
      .notNull()
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    playlistRef: text("playlist_ref")
      .notNull()
      .references(() => playlist.playlistId),
    tuneRef: text("tune_ref")
      .notNull()
      .references(() => tune.id),
    practiced: text("practiced"),
    quality: integer("quality"),
    easiness: real("easiness"),
    difficulty: real("difficulty"),
    stability: real("stability"),
    interval: integer("interval"),
    step: integer("step"),
    repetitions: integer("repetitions"),
    lapses: integer("lapses"),
    elapsedDays: integer("elapsed_days"),
    state: integer("state"),
    due: text("due"),
    backupPracticed: text("backup_practiced"),
    goal: text("goal").default("recall"),
    technique: text("technique"),
    ...sqliteSyncColumns,
  },
  (t) => [
    uniqueIndex("practice_record_tune_ref_playlist_ref_practiced_key").on(
      t.tuneRef,
      t.playlistRef,
      t.practiced
    ),
    index("idx_practice_record_id").on(t.id),
    index("idx_practice_record_practiced").on(t.practiced),
    index("idx_practice_record_tune_playlist_practiced").on(
      t.tuneRef,
      t.playlistRef,
      t.practiced
    ),
  ]
);

export const prefsSchedulingOptions = sqliteTable("prefs_scheduling_options", {
  userId: text("user_id")
    .notNull()
    .references(() => userProfile.id)
    .primaryKey(),
  acceptableDelinquencyWindow: integer("acceptable_delinquency_window")
    .notNull()
    .default(21),
  minReviewsPerDay: integer("min_reviews_per_day"),
  maxReviewsPerDay: integer("max_reviews_per_day"),
  daysPerWeek: integer("days_per_week"),
  weeklyRules: text("weekly_rules"),
  exceptions: text("exceptions"),
  autoScheduleNew: integer("auto_schedule_new").notNull().default(1),
  ...sqliteSyncColumns,
});

export const prefsSpacedRepetition = sqliteTable(
  "prefs_spaced_repetition",
  {
    userId: text("user_id")
      .notNull()
      .references(() => userProfile.id),
    algType: text("alg_type").notNull(),
    fsrsWeights: text("fsrs_weights"),
    requestRetention: real("request_retention"),
    maximumInterval: integer("maximum_interval"),
    learningSteps: text("learning_steps"),
    relearningSteps: text("relearning_steps"),
    enableFuzzing: integer("enable_fuzzing"),
    ...sqliteSyncColumns,
  },
  (t) => [primaryKey({ columns: [t.userId, t.algType] })]
);

export const reference = sqliteTable(
  "reference",
  {
    id: text("id")
      .notNull()
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    url: text("url").notNull(),
    refType: text("ref_type"),
    tuneRef: text("tune_ref")
      .notNull()
      .references(() => tune.id),
    userRef: text("user_ref").references(() => userProfile.id),
    comment: text("comment"),
    title: text("title"),
    public: integer("public"),
    favorite: integer("favorite"),
    deleted: integer("deleted").notNull().default(0),
    displayOrder: integer("display_order").notNull().default(0),
    ...sqliteSyncColumns,
  },
  (t) => [
    index("idx_reference_tune_public").on(t.tuneRef, t.public),
    index("idx_reference_tune_user_ref").on(t.tuneRef, t.userRef),
    index("idx_reference_user_tune_public").on(t.userRef, t.tuneRef, t.public),
  ]
);

export const syncChangeLog = sqliteTable(
  "sync_change_log",
  {
    tableName: text("table_name").notNull().primaryKey(),
    changedAt: text("changed_at").notNull(),
  },
  (t) => [index("idx_sync_change_log_changed_at").on(t.changedAt)]
);

export const tabGroupMainState = sqliteTable("tab_group_main_state", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userId: text("user_id")
    .notNull()
    .references(() => userProfile.id),
  whichTab: text("which_tab").default("practice"),
  playlistId: text("playlist_id"),
  tabSpec: text("tab_spec"),
  practiceShowSubmitted: integer("practice_show_submitted").default(0),
  practiceModeFlashcard: integer("practice_mode_flashcard").default(0),
  sidebarDockPosition: text("sidebar_dock_position").default("left"),
  ...sqliteSyncColumns,
});

export const tableState = sqliteTable(
  "table_state",
  {
    userId: text("user_id")
      .notNull()
      .references(() => userProfile.id),
    screenSize: text("screen_size").notNull(),
    purpose: text("purpose").notNull(),
    playlistId: text("playlist_id")
      .notNull()
      .references(() => playlist.playlistId),
    settings: text("settings"),
    currentTune: text("current_tune"),
    ...sqliteSyncColumns,
  },
  (t) => [
    primaryKey({ columns: [t.userId, t.screenSize, t.purpose, t.playlistId] }),
  ]
);

export const tableTransientData = sqliteTable(
  "table_transient_data",
  {
    userId: text("user_id")
      .notNull()
      .references(() => userProfile.id),
    tuneId: text("tune_id")
      .notNull()
      .references(() => tune.id),
    playlistId: text("playlist_id")
      .notNull()
      .references(() => playlist.playlistId),
    purpose: text("purpose"),
    notePrivate: text("note_private"),
    notePublic: text("note_public"),
    recallEval: text("recall_eval"),
    practiced: text("practiced"),
    quality: integer("quality"),
    easiness: real("easiness"),
    difficulty: real("difficulty"),
    interval: integer("interval"),
    step: integer("step"),
    repetitions: integer("repetitions"),
    due: text("due"),
    backupPracticed: text("backup_practiced"),
    goal: text("goal"),
    technique: text("technique"),
    stability: real("stability"),
    state: integer("state").default(2),
    ...sqliteSyncColumns,
  },
  (t) => [primaryKey({ columns: [t.tuneId, t.userId, t.playlistId] })]
);

export const tag = sqliteTable(
  "tag",
  {
    tagId: text("tag_id")
      .notNull()
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userRef: text("user_ref")
      .notNull()
      .references(() => userProfile.id),
    tuneRef: text("tune_ref")
      .notNull()
      .references(() => tune.id),
    tagText: text("tag_text").notNull(),
    ...sqliteSyncColumns,
  },
  (t) => [
    uniqueIndex("tag_user_ref_tune_ref_tag_text_key").on(
      t.userRef,
      t.tuneRef,
      t.tagText
    ),
    index("idx_tag_user_ref_tag_text").on(t.userRef, t.tagText),
    index("idx_tag_user_ref_tune_ref").on(t.userRef, t.tuneRef),
  ]
);

export const tune = sqliteTable(
  "tune",
  {
    id: text("id")
      .notNull()
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    idForeign: text("id_foreign"),
    primaryOrigin: text("primary_origin").default("irishtune.info"),
    title: text("title"),
    type: text("type"),
    structure: text("structure"),
    mode: text("mode"),
    incipit: text("incipit"),
    genre: text("genre").references(() => genre.id),
    privateFor: text("private_for").references(() => userProfile.id),
    deleted: integer("deleted").notNull().default(0),
    composer: text("composer"),
    artist: text("artist"),
    releaseYear: integer("release_year"),
    ...sqliteSyncColumns,
  },
  (t) => [index("idx_tune_genre").on(t.genre)]
);

export const tuneOverride = sqliteTable("tune_override", {
  id: text("id")
    .notNull()
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  tuneRef: text("tune_ref")
    .notNull()
    .references(() => tune.id),
  userRef: text("user_ref")
    .notNull()
    .references(() => userProfile.id),
  title: text("title"),
  type: text("type"),
  structure: text("structure"),
  genre: text("genre").references(() => genre.id),
  mode: text("mode"),
  incipit: text("incipit"),
  deleted: integer("deleted").notNull().default(0),
  composer: text("composer"),
  artist: text("artist"),
  releaseYear: integer("release_year"),
  idForeign: text("id_foreign"),
  ...sqliteSyncColumns,
});

export const tuneType = sqliteTable("tune_type", {
  id: text("id").notNull().primaryKey(),
  name: text("name"),
  rhythm: text("rhythm"),
  description: text("description"),
});

export const userGenreSelection = sqliteTable(
  "user_genre_selection",
  {
    userId: text("user_id")
      .notNull()
      .references(() => userProfile.id),
    genreId: text("genre_id")
      .notNull()
      .references(() => genre.id),
    createdAt: text("created_at")
      .notNull()
      .$defaultFn(() => new Date().toISOString()),
    ...sqliteSyncColumns,
  },
  (t) => [
    primaryKey({ columns: [t.userId, t.genreId] }),
    index("idx_user_genre_selection_genre_id").on(t.genreId),
    index("idx_user_genre_selection_user_id").on(t.userId),
  ]
);

export const userProfile = sqliteTable(
  "user_profile",
  {
    id: text("id")
      .notNull()
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    supabaseUserId: text("supabase_user_id").notNull(),
    name: text("name"),
    email: text("email"),
    srAlgType: text("sr_alg_type"),
    phone: text("phone"),
    phoneVerified: text("phone_verified"),
    acceptableDelinquencyWindow: integer(
      "acceptable_delinquency_window"
    ).default(21),
    avatarUrl: text("avatar_url"),
    deleted: integer("deleted").notNull().default(0),
    ...sqliteSyncColumns,
  },
  (t) => [uniqueIndex("user_profile_supabase_user_id_key").on(t.supabaseUserId)]
);
