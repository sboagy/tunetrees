/**
 * AUTO-GENERATED FILE â€” DO NOT EDIT.
 *
 * Source: Postgres catalogs (schema: public)
 * Generated by: oosync/src/codegen-schema.ts
 */

import {
  type SyncableTableName as GeneratedSyncableTableName,
  SYNCABLE_TABLES as SYNCABLE_TABLES_GENERATED,
  TABLE_REGISTRY_CORE,
  type TableMetaCore,
} from "@shared-generated/sync";

export type ChangeCategory = string | null;
export type SyncableTableName = GeneratedSyncableTableName;

export interface TableMeta {
  primaryKey: string | string[];
  uniqueKeys: string[] | null;
  timestamps: string[];
  booleanColumns: string[];
  supportsIncremental: boolean;
  hasDeletedFlag: boolean;
  changeCategory: ChangeCategory;
  normalize?: (row: Record<string, unknown>) => Record<string, unknown>;
  columnDescriptions?: Record<string, string>;
}

export const SYNCABLE_TABLES = SYNCABLE_TABLES_GENERATED;

function normalizeDatetimeFields(row: Record<string, unknown>, fields: string[]): Record<string, unknown> {
  const normalized = { ...row };
  for (const field of fields) {
    const value = normalized[field];
    if (typeof value === "string") {
      let result = value.includes(" ") ? value.replace(" ", "T") : value;
      if (/Z$/i.test(result) || /[+-]\d{2}:?\d{2}$/.test(result)) {
        normalized[field] = result;
        continue;
      }
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(result)) {
        result = `${result}Z`;
      }
      normalized[field] = result;
    }
  }
  return normalized;
}

const TABLE_EXTRAS: Record<
  SyncableTableName,
  Pick<TableMeta, "changeCategory" | "normalize" | "columnDescriptions">
> = {
  "daily_practice_queue": {
    changeCategory: "practice",
    normalize: (row) => normalizeDatetimeFields(row, ["window_start_utc", "window_end_utc", "generated_at", "completed_at", "snapshot_coalesced_ts"]),
    columnDescriptions: {
      id: "Unique ID for the queue entry.",
      user_ref: "User profile ID that owns this queue entry.",
      playlist_ref: "Playlist ID that the tune is scheduled under.",
      mode: "Tune mode captured when the queue was generated.",
      queue_date: "Practice date (local day) for this queue row.",
      window_start_utc: "UTC timestamp marking the start of the practice window.",
      window_end_utc: "UTC timestamp marking the end of the practice window.",
      tune_ref: "Tune ID scheduled for this queue entry.",
      bucket: "Queue bucket (Due Today, Lapsed, New, Old Lapsed).",
      order_index: "Ordering position within the bucket.",
      snapshot_coalesced_ts: "Timestamp of the snapshot used to generate the queue.",
      scheduled_snapshot: "Scheduled override captured in the queue snapshot.",
      latest_due_snapshot: "Latest due timestamp captured in the queue snapshot.",
      acceptable_delinquency_window_snapshot: "Delinquency window captured in the queue snapshot.",
      tz_offset_minutes_snapshot: "Timezone offset (minutes) captured in the queue snapshot.",
      generated_at: "UTC timestamp when the queue entry was generated.",
      completed_at: "UTC timestamp when the queue entry was completed.",
      exposures_required: "Number of required exposures in the queue window.",
      exposures_completed: "Number of exposures completed in the queue window.",
      outcome: "Completion outcome label captured by the queue.",
      active: "Whether this queue entry is currently active.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "genre": {
    changeCategory: "catalog",
    columnDescriptions: {
      id: "Short identifier for the genre (e.g. itrad).",
      name: "Display name for the genre.",
      region: "Geographic region associated with the genre.",
      description: "Optional notes describing the genre.",
    },
  },
  "genre_tune_type": {
    changeCategory: "catalog",
    columnDescriptions: {
      genre_id: "Genre ID included in the association.",
      tune_type_id: "Tune type ID included in the association.",
    },
  },
  "instrument": {
    changeCategory: "catalog",
    columnDescriptions: {
      id: "Instrument ID.",
      private_to_user: "User profile ID if this instrument is private.",
      instrument: "Instrument display name.",
      description: "Short description of the instrument.",
      genre_default: "Default genre ID for tunes on this instrument.",
      deleted: "Soft-delete flag for the instrument.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "note": {
    changeCategory: "repertoire",
    columnDescriptions: {
      id: "Note ID.",
      user_ref: "User profile ID that owns the note.",
      tune_ref: "Tune ID that the note references.",
      playlist_ref: "Playlist ID that the note is associated with.",
      created_date: "When the note was created.",
      note_text: "Full note text.",
      public: "Whether the note is public.",
      favorite: "Whether the note is marked as a favorite.",
      deleted: "Soft-delete flag for the note.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
      display_order: "User-defined ordering value for notes.",
    },
  },
  "playlist": {
    changeCategory: "repertoire",
    columnDescriptions: {
      playlist_id: "Playlist ID.",
      user_ref: "User profile ID that owns the playlist.",
      name: "Playlist display name.",
      instrument_ref: "Instrument ID associated with the playlist.",
      genre_default: "Default genre ID for the playlist.",
      sr_alg_type: "Spaced repetition algorithm preference for this playlist.",
      deleted: "Soft-delete flag for the playlist.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "playlist_tune": {
    changeCategory: "repertoire",
    columnDescriptions: {
      playlist_ref: "Playlist ID containing the tune.",
      tune_ref: "Tune ID linked to the playlist.",
      current: "Timestamp when the tune became current in the playlist.",
      learned: "Timestamp when the tune was learned.",
      scheduled: "Manual override for the next scheduled practice.",
      goal: "Practice goal for the tune in this playlist.",
      deleted: "Soft-delete flag for the playlist entry.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "practice_record": {
    changeCategory: "practice",
    normalize: (row) => normalizeDatetimeFields(row, ["practiced", "backup_practiced", "due"]),
    columnDescriptions: {
      id: "Practice record ID.",
      playlist_ref: "Playlist ID practiced.",
      tune_ref: "Tune ID practiced.",
      practiced: "Timestamp when the practice occurred.",
      quality: "Rating of the practice response.",
      easiness: "FSRS/SM-2 easiness factor.",
      difficulty: "FSRS difficulty value.",
      stability: "FSRS stability value.",
      interval: "Computed interval (days) until next practice.",
      step: "Learning step used in scheduling.",
      repetitions: "Number of repetitions completed.",
      lapses: "Number of lapses recorded.",
      elapsed_days: "Days since the previous practice.",
      state: "Scheduler state (new/learning/review/relearning).",
      due: "Next due timestamp.",
      backup_practiced: "Backup practiced timestamp (pre-migration).",
      goal: "Practice goal used for the record.",
      technique: "Scheduling algorithm used for the record.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "prefs_scheduling_options": {
    changeCategory: "user",
    columnDescriptions: {
      user_id: "User profile ID that owns these preferences.",
      acceptable_delinquency_window: "Days after due date considered acceptable.",
      min_reviews_per_day: "Minimum reviews per day target.",
      max_reviews_per_day: "Maximum reviews per day limit.",
      days_per_week: "Number of active practice days per week.",
      weekly_rules: "Weekly scheduling rules as JSON.",
      exceptions: "Date exceptions for scheduling as JSON.",
      auto_schedule_new: "Whether new tunes are auto-scheduled.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "prefs_spaced_repetition": {
    changeCategory: "user",
    columnDescriptions: {
      user_id: "User profile ID that owns these preferences.",
      alg_type: "Algorithm type (FSRS/SM2).",
      fsrs_weights: "Stored FSRS model weights.",
      request_retention: "Requested retention rate.",
      maximum_interval: "Maximum interval (days) cap.",
      learning_steps: "Learning steps configuration.",
      relearning_steps: "Relearning steps configuration.",
      enable_fuzzing: "Whether to apply fuzzing to intervals.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "reference": {
    changeCategory: "repertoire",
    columnDescriptions: {
      id: "Reference ID.",
      url: "Reference URL (website, audio, video).",
      ref_type: "Reference type (website/audio/video).",
      tune_ref: "Tune ID the reference points to.",
      user_ref: "User profile ID that owns the reference.",
      comment: "Optional comment for the reference.",
      title: "Optional display title for the reference.",
      public: "Whether the reference is public.",
      favorite: "Whether the reference is marked as a favorite.",
      deleted: "Soft-delete flag for the reference.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
      display_order: "User-defined ordering value for references.",
    },
  },
  "tab_group_main_state": {
    changeCategory: null,
    columnDescriptions: {
      id: "Tab group state ID.",
      user_id: "User profile ID that owns the state.",
      which_tab: "Current selected tab.",
      playlist_id: "Active playlist ID.",
      tab_spec: "Serialized tab specification payload.",
      practice_show_submitted: "Whether to show submitted tunes in practice view.",
      practice_mode_flashcard: "Whether flashcard mode is enabled.",
      sidebar_dock_position: "Sidebar dock position setting.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "table_state": {
    changeCategory: null,
    columnDescriptions: {
      user_id: "User profile ID that owns the table state.",
      screen_size: "Screen size identifier (small/full).",
      purpose: "Table purpose (practice/repertoire/catalog/analysis).",
      playlist_id: "Playlist ID tied to the state.",
      settings: "Serialized table settings JSON.",
      current_tune: "Tune ID that is currently selected.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "table_transient_data": {
    changeCategory: "practice",
    columnDescriptions: {
      user_id: "User profile ID that owns the staged data.",
      tune_id: "Tune ID being staged.",
      playlist_id: "Playlist ID associated with the staged data.",
      purpose: "Practice purpose for the staged session.",
      note_private: "Private note text for the staged session.",
      note_public: "Public note text for the staged session.",
      recall_eval: "Recall evaluation selection.",
      practiced: "Timestamp for the staged practice.",
      quality: "Staged quality rating.",
      easiness: "Staged easiness factor.",
      difficulty: "Staged difficulty value.",
      interval: "Staged interval (days).",
      step: "Staged learning step.",
      repetitions: "Staged repetitions count.",
      due: "Staged due timestamp.",
      backup_practiced: "Backup practiced timestamp (pre-migration).",
      goal: "Staged practice goal.",
      technique: "Staged scheduling technique.",
      stability: "Staged stability value.",
      state: "Staged scheduler state.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "tag": {
    changeCategory: "repertoire",
    columnDescriptions: {
      tag_id: "Tag ID.",
      user_ref: "User profile ID that owns the tag.",
      tune_ref: "Tune ID that the tag applies to.",
      tag_text: "Tag text value.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "tune": {
    changeCategory: "catalog",
    columnDescriptions: {
      id: "Tune ID.",
      id_foreign: "External tune identifier (e.g. irishtune.info, Spotify).",
      primary_origin: "Primary source for the tune metadata.",
      title: "Tune title.",
      type: "Tune type classification (reel, jig, etc.).",
      structure: "Tune structure (e.g. AABB).",
      mode: "Musical mode.",
      incipit: "Opening notation/incipit text.",
      genre: "Genre ID assigned to the tune.",
      composer: "Composer name (classical/choral).",
      artist: "Artist name (pop/rock/jazz).",
      release_year: "Release year for the recording or tune.",
      private_for: "User profile ID if the tune is private.",
      deleted: "Soft-delete flag for the tune.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "tune_override": {
    changeCategory: "repertoire",
    columnDescriptions: {
      id: "Tune override ID.",
      tune_ref: "Tune ID being overridden.",
      user_ref: "User profile ID that owns the override.",
      title: "Override title.",
      type: "Override tune type.",
      structure: "Override structure.",
      genre: "Override genre ID.",
      mode: "Override mode.",
      incipit: "Override incipit.",
      composer: "Override composer name.",
      artist: "Override artist name.",
      id_foreign: "Override external ID.",
      release_year: "Override release year.",
      deleted: "Soft-delete flag for the override.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
  "tune_type": {
    changeCategory: "catalog",
    columnDescriptions: {
      id: "Tune type ID.",
      name: "Tune type display name.",
      rhythm: "Rhythm category for the tune type.",
      description: "Description of the tune type.",
    },
  },
  "user_profile": {
    changeCategory: "user",
    columnDescriptions: {
      id: "User profile ID.",
      supabase_user_id: "Supabase auth user ID.",
      name: "User display name.",
      email: "User email address.",
      sr_alg_type: "Preferred spaced repetition algorithm.",
      phone: "User phone number.",
      phone_verified: "Timestamp when phone was verified.",
      acceptable_delinquency_window: "User-level delinquency window preference.",
      avatar_url: "Avatar image URL.",
      deleted: "Soft-delete flag for the user profile.",
      sync_version: "Sync version for offline change tracking.",
      last_modified_at: "UTC timestamp of the last modification.",
      device_id: "Device identifier that last modified the row.",
    },
  },
};

export const TABLE_REGISTRY_MERGED: Record<SyncableTableName, TableMeta> = Object.fromEntries(
  Object.entries(TABLE_REGISTRY_CORE).map(([tableName, core]) => {
    const extras = TABLE_EXTRAS[tableName as SyncableTableName];
    return [tableName, { ...(core as TableMetaCore), ...extras }];
  })
) as Record<SyncableTableName, TableMeta>;

export const TABLE_REGISTRY: Record<string, TableMeta> = TABLE_REGISTRY_MERGED;

function getRequiredMeta(tableName: string): TableMeta {
  const meta = TABLE_REGISTRY[tableName];
  if (!meta) {
    throw new Error(`Unknown table: ${tableName}`);
  }
  return meta;
}

export const COMPOSITE_PK_TABLES: SyncableTableName[] = (() => {
  const tables: SyncableTableName[] = [];
  for (const tableName of SYNCABLE_TABLES) {
    const pk = TABLE_REGISTRY_MERGED[tableName].primaryKey;
    if (Array.isArray(pk)) {
      tables.push(tableName);
    }
  }
  return tables;
})();

export const NON_STANDARD_PK_TABLES: Partial<Record<SyncableTableName, string>> = (() => {
  const map: Partial<Record<SyncableTableName, string>> = {};
  for (const tableName of SYNCABLE_TABLES) {
    const pk = TABLE_REGISTRY_MERGED[tableName].primaryKey;
    if (typeof pk === "string" && pk !== "id") {
      map[tableName] = pk;
    }
  }
  return map;
})();

export function getPrimaryKey(tableName: string): string | string[] {
  const pk = getRequiredMeta(tableName).primaryKey;
  return Array.isArray(pk) ? [...pk] : pk;
}

export function getUniqueKeys(tableName: string): string[] | null {
  const uniqueKeys = getRequiredMeta(tableName).uniqueKeys;
  return uniqueKeys ? [...uniqueKeys] : null;
}

export function getConflictTarget(tableName: string): string[] {
  const meta = getRequiredMeta(tableName);
  if (meta.uniqueKeys) return [...meta.uniqueKeys];

  const pk = meta.primaryKey;
  return Array.isArray(pk) ? [...pk] : [pk];
}

export function supportsIncremental(tableName: string): boolean {
  return TABLE_REGISTRY[tableName]?.supportsIncremental ?? false;
}

export function hasDeletedFlag(tableName: string): boolean {
  return TABLE_REGISTRY[tableName]?.hasDeletedFlag ?? false;
}

export function getBooleanColumns(tableName: string): string[] {
  return [...(TABLE_REGISTRY[tableName]?.booleanColumns ?? [])];
}

export function getNormalizer(tableName: string):
  | ((row: Readonly<Record<string, unknown>>) => Record<string, unknown>)
  | undefined {
  const normalize = TABLE_REGISTRY[tableName]?.normalize;
  return normalize ? (row) => normalize(row as Record<string, unknown>) : undefined;
}

export function isRegisteredTable(tableName: string): boolean {
  return tableName in TABLE_REGISTRY;
}

export function hasCompositePK(tableName: string): boolean {
  return Array.isArray(TABLE_REGISTRY[tableName]?.primaryKey);
}

export function buildRowIdForOutbox(
  tableName: string,
  row: Readonly<Record<string, unknown>>
): string {
  const pk = getPrimaryKey(tableName);
  if (Array.isArray(pk)) {
    const keyObj: Record<string, unknown> = {};
    for (const col of pk) {
      keyObj[col] = row[col];
    }
    return JSON.stringify(keyObj);
  }
  return String(row[pk]);
}

export function parseOutboxRowId(
  tableName: string,
  rowId: string
): Record<string, unknown> | string {
  const pk = getPrimaryKey(tableName);
  if (Array.isArray(pk)) {
    try {
      return JSON.parse(rowId) as Record<string, unknown>;
    } catch {
      throw new Error(`Invalid JSON row_id for composite key table ${tableName}: ${rowId}`);
    }
  }
  return rowId;
}

export const TABLE_SYNC_ORDER: Record<string, number> = {
  "daily_practice_queue": 1,
  "genre": 2,
  "genre_tune_type": 4,
  "instrument": 6,
  "note": 13,
  "playlist": 7,
  "playlist_tune": 14,
  "practice_record": 15,
  "prefs_scheduling_options": 8,
  "prefs_spaced_repetition": 9,
  "reference": 16,
  "tab_group_main_state": 10,
  "table_state": 11,
  "table_transient_data": 17,
  "tag": 18,
  "tune": 12,
  "tune_override": 19,
  "tune_type": 3,
  "user_profile": 5,
};

export const TABLE_TO_SCHEMA_KEY: Record<string, string> = {
  "daily_practice_queue": "dailyPracticeQueue",
  "genre": "genre",
  "genre_tune_type": "genreTuneType",
  "instrument": "instrument",
  "note": "note",
  "playlist": "playlist",
  "playlist_tune": "playlistTune",
  "practice_record": "practiceRecord",
  "prefs_scheduling_options": "prefsSchedulingOptions",
  "prefs_spaced_repetition": "prefsSpacedRepetition",
  "reference": "reference",
  "tab_group_main_state": "tabGroupMainState",
  "table_state": "tableState",
  "table_transient_data": "tableTransientData",
  "tag": "tag",
  "tune": "tune",
  "tune_override": "tuneOverride",
  "tune_type": "tuneType",
  "user_profile": "userProfile",
};
