/**
 * AUTO-GENERATED FILE â€” DO NOT EDIT.
 *
 * Source: Postgres catalogs (schema: public)
 * Generated by: oosync/src/codegen-schema.ts
 */

import {
  type SyncableTableName as GeneratedSyncableTableName,
  SYNCABLE_TABLES as SYNCABLE_TABLES_GENERATED,
  TABLE_REGISTRY_CORE,
  type TableMetaCore,
} from "@shared-generated/sync";

export type ChangeCategory = string | null;
export type SyncableTableName = GeneratedSyncableTableName;

export interface TableMeta {
  primaryKey: string | string[];
  uniqueKeys: string[] | null;
  timestamps: string[];
  booleanColumns: string[];
  supportsIncremental: boolean;
  hasDeletedFlag: boolean;
  changeCategory: ChangeCategory;
  normalize?: (row: Record<string, unknown>) => Record<string, unknown>;
  columnDescriptions?: Record<string, string>;
}

export const SYNCABLE_TABLES = SYNCABLE_TABLES_GENERATED;

function normalizeDatetimeFields(row: Record<string, unknown>, fields: string[]): Record<string, unknown> {
  const normalized = { ...row };
  for (const field of fields) {
    const value = normalized[field];
    if (typeof value === "string") {
      let result = value.includes(" ") ? value.replace(" ", "T") : value;
      if (/Z$/i.test(result) || /[+-]\d{2}:?\d{2}$/.test(result)) {
        normalized[field] = result;
        continue;
      }
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(result)) {
        result = `${result}Z`;
      }
      normalized[field] = result;
    }
  }
  return normalized;
}

const TABLE_EXTRAS: Record<SyncableTableName, Pick<TableMeta, "changeCategory" | "normalize" | "columnDescriptions">> = {
  "daily_practice_queue": {
    changeCategory: "practice",
    normalize: (row) => normalizeDatetimeFields(row, ["window_start_utc", "window_end_utc", "generated_at", "completed_at", "snapshot_coalesced_ts"]),
  },
  "genre": {
    changeCategory: "catalog",
  },
  "genre_tune_type": {
    changeCategory: "catalog",
  },
  "instrument": {
    changeCategory: "catalog",
  },
  "note": {
    changeCategory: "repertoire",
    columnDescriptions: {
  "display_order": "User-defined display order for drag-and-drop reordering in the UI"
},
  },
  "playlist": {
    changeCategory: "repertoire",
  },
  "playlist_tune": {
    changeCategory: "repertoire",
  },
  "practice_record": {
    changeCategory: "practice",
    normalize: (row) => normalizeDatetimeFields(row, ["practiced", "backup_practiced", "due"]),
  },
  "prefs_scheduling_options": {
    changeCategory: "user",
    columnDescriptions: {
  "auto_schedule_new": "Include never-practiced tunes in daily practice queue (Q3 bucket). Default: true"
},
  },
  "prefs_spaced_repetition": {
    changeCategory: "user",
  },
  "reference": {
    changeCategory: "repertoire",
    columnDescriptions: {
  "display_order": "User-defined display order for drag-and-drop reordering in the UI"
},
  },
  "tab_group_main_state": {
    changeCategory: null,
  },
  "table_state": {
    changeCategory: null,
  },
  "table_transient_data": {
    changeCategory: "practice",
  },
  "tag": {
    changeCategory: "repertoire",
  },
  "tune": {
    changeCategory: "catalog",
  },
  "tune_override": {
    changeCategory: "repertoire",
  },
  "tune_type": {
    changeCategory: "catalog",
  },
  "user_profile": {
    changeCategory: "user",
  },
};

export const TABLE_REGISTRY_MERGED: Record<SyncableTableName, TableMeta> = Object.fromEntries(
  Object.entries(TABLE_REGISTRY_CORE).map(([tableName, core]) => {
    const extras = TABLE_EXTRAS[tableName as SyncableTableName];
    return [tableName, { ...(core as TableMetaCore), ...extras }];
  })
) as Record<SyncableTableName, TableMeta>;

export const TABLE_REGISTRY: Record<string, TableMeta> = TABLE_REGISTRY_MERGED;

function getRequiredMeta(tableName: string): TableMeta {
  const meta = TABLE_REGISTRY[tableName];
  if (!meta) {
    throw new Error(`Unknown table: ${tableName}`);
  }
  return meta;
}

export const COMPOSITE_PK_TABLES: SyncableTableName[] = (() => {
  const tables: SyncableTableName[] = [];
  for (const tableName of SYNCABLE_TABLES) {
    const pk = TABLE_REGISTRY_MERGED[tableName].primaryKey;
    if (Array.isArray(pk)) {
      tables.push(tableName);
    }
  }
  return tables;
})();

export const NON_STANDARD_PK_TABLES: Partial<Record<SyncableTableName, string>> = (() => {
  const map: Partial<Record<SyncableTableName, string>> = {};
  for (const tableName of SYNCABLE_TABLES) {
    const pk = TABLE_REGISTRY_MERGED[tableName].primaryKey;
    if (typeof pk === "string" && pk !== "id") {
      map[tableName] = pk;
    }
  }
  return map;
})();

export function getPrimaryKey(tableName: string): string | string[] {
  const pk = getRequiredMeta(tableName).primaryKey;
  return Array.isArray(pk) ? [...pk] : pk;
}

export function getUniqueKeys(tableName: string): string[] | null {
  const uniqueKeys = getRequiredMeta(tableName).uniqueKeys;
  return uniqueKeys ? [...uniqueKeys] : null;
}

export function getConflictTarget(tableName: string): string[] {
  const meta = getRequiredMeta(tableName);
  if (meta.uniqueKeys) return [...meta.uniqueKeys];

  const pk = meta.primaryKey;
  return Array.isArray(pk) ? [...pk] : [pk];
}

export function supportsIncremental(tableName: string): boolean {
  return TABLE_REGISTRY[tableName]?.supportsIncremental ?? false;
}

export function hasDeletedFlag(tableName: string): boolean {
  return TABLE_REGISTRY[tableName]?.hasDeletedFlag ?? false;
}

export function getBooleanColumns(tableName: string): string[] {
  return [...(TABLE_REGISTRY[tableName]?.booleanColumns ?? [])];
}

export function getNormalizer(tableName: string):
  | ((row: Readonly<Record<string, unknown>>) => Record<string, unknown>)
  | undefined {
  const normalize = TABLE_REGISTRY[tableName]?.normalize;
  return normalize ? (row) => normalize(row as Record<string, unknown>) : undefined;
}

export function isRegisteredTable(tableName: string): boolean {
  return tableName in TABLE_REGISTRY;
}

export function hasCompositePK(tableName: string): boolean {
  return Array.isArray(TABLE_REGISTRY[tableName]?.primaryKey);
}

export function buildRowIdForOutbox(
  tableName: string,
  row: Readonly<Record<string, unknown>>
): string {
  const pk = getPrimaryKey(tableName);
  if (Array.isArray(pk)) {
    const keyObj: Record<string, unknown> = {};
    for (const col of pk) {
      keyObj[col] = row[col];
    }
    return JSON.stringify(keyObj);
  }
  return String(row[pk]);
}

export function parseOutboxRowId(
  tableName: string,
  rowId: string
): Record<string, unknown> | string {
  const pk = getPrimaryKey(tableName);
  if (Array.isArray(pk)) {
    try {
      return JSON.parse(rowId) as Record<string, unknown>;
    } catch {
      throw new Error(`Invalid JSON row_id for composite key table ${tableName}: ${rowId}`);
    }
  }
  return rowId;
}

export const TABLE_SYNC_ORDER: Record<string, number> = {
  "daily_practice_queue": 1,
  "genre": 2,
  "genre_tune_type": 4,
  "instrument": 6,
  "note": 13,
  "playlist": 7,
  "playlist_tune": 14,
  "practice_record": 15,
  "prefs_scheduling_options": 8,
  "prefs_spaced_repetition": 9,
  "reference": 16,
  "tab_group_main_state": 10,
  "table_state": 11,
  "table_transient_data": 17,
  "tag": 18,
  "tune": 12,
  "tune_override": 19,
  "tune_type": 3,
  "user_profile": 5,
};

export const TABLE_TO_SCHEMA_KEY: Record<string, string> = {
  "daily_practice_queue": "dailyPracticeQueue",
  "genre": "genre",
  "genre_tune_type": "genreTuneType",
  "instrument": "instrument",
  "note": "note",
  "playlist": "playlist",
  "playlist_tune": "playlistTune",
  "practice_record": "practiceRecord",
  "prefs_scheduling_options": "prefsSchedulingOptions",
  "prefs_spaced_repetition": "prefsSpacedRepetition",
  "reference": "reference",
  "tab_group_main_state": "tabGroupMainState",
  "table_state": "tableState",
  "table_transient_data": "tableTransientData",
  "tag": "tag",
  "tune": "tune",
  "tune_override": "tuneOverride",
  "tune_type": "tuneType",
  "user_profile": "userProfile",
};
