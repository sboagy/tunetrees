import * as fs from "node:fs";
import * as path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";
import postgres from "postgres";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DEFAULT_OUTPUT_SQLITE_SCHEMA_FILE = path.join(
  __dirname,
  "../../drizzle/schema-sqlite.generated.ts"
);

const DEFAULT_OUTPUT_TABLE_META_FILE = path.join(
  __dirname,
  "../../shared/table-meta.generated.ts"
);

const LOCAL_SUPABASE_DATABASE_URL =
  "postgresql://postgres:postgres@127.0.0.1:54322/postgres";

function isLocalSupabaseDatabaseUrl(databaseUrl: string): boolean {
  try {
    const url = new URL(databaseUrl);
    const hostname = url.hostname;
    const port = url.port;

    const isLocalHost = hostname === "127.0.0.1" || hostname === "localhost";
    return isLocalHost && port === "54322";
  } catch {
    return false;
  }
}

function getDefaultDatabaseUrl(): string {
  // Prefer an explicit env var to avoid accidentally introspecting a remote DB.
  const oosyncUrl = process.env.OOSYNC_DATABASE_URL;
  if (oosyncUrl) return oosyncUrl;

  // Only trust DATABASE_URL if it points at local Supabase.
  const databaseUrl = process.env.DATABASE_URL;
  if (databaseUrl && isLocalSupabaseDatabaseUrl(databaseUrl))
    return databaseUrl;

  return LOCAL_SUPABASE_DATABASE_URL;
}

const DEFAULT_DATABASE_URL = getDefaultDatabaseUrl();

interface IArgs {
  check: boolean;
  databaseUrl: string;
  schema: string;
  strict: boolean;
  configPath: string | null;
}

interface ITableMetaCore {
  primaryKey: string | string[];
  uniqueKeys: string[] | null;
  timestamps: string[];
  booleanColumns: string[];
  supportsIncremental: boolean;
  hasDeletedFlag: boolean;
}

interface ICodegenConfigFile {
  outputs?: {
    sqliteSchemaFile?: string;
    tableMetaFile?: string;
  };
  tableMeta?: {
    syncableTables?: string[];
    tableRegistryCore?: Record<string, ITableMetaCore>;
  };
}

interface IColumnRow {
  table_name: string;
  column_name: string;
  data_type: string;
  udt_name: string;
  is_nullable: "YES" | "NO";
  column_default: string | null;
  ordinal_position: number;
}

interface IConstraintColumnRow {
  table_name: string;
  constraint_name: string;
  column_name: string;
  position: number;
}

interface IIndexKeyRow {
  table_name: string;
  index_name: string;
  keydef: string;
  position: number;
}

interface IForeignKeyRow {
  table_name: string;
  constraint_name: string;
  column_name: string;
  ref_table_name: string;
  ref_column_name: string;
  position: number;
}

function parseArgs(argv: string[]): IArgs {
  const check = argv.includes("--check");
  const strict = !argv.includes("--lenient");

  const schemaArg = argv.find((a) => a.startsWith("--schema="));
  const schema = schemaArg ? schemaArg.split("=", 2)[1] : "public";

  const urlArg = argv.find((a) => a.startsWith("--databaseUrl="));
  const databaseUrl = urlArg ? urlArg.split("=", 2)[1] : DEFAULT_DATABASE_URL;

  const configArg = argv.find((a) => a.startsWith("--config="));
  const configPath = configArg ? configArg.split("=", 2)[1] : null;

  return { check, databaseUrl, schema, strict, configPath };
}

function createHeader(params: { schema: string }): string {
  return `/**
 * AUTO-GENERATED FILE — DO NOT EDIT.
 *
 * Source: Postgres catalogs (schema: ${params.schema})
 * Generated by: oosync/src/codegen-schema.ts
 */\n\n`;
}

function createTableMetaHeader(params: { schema: string }): string {
  return `/**
 * AUTO-GENERATED FILE — DO NOT EDIT.
 *
 * Source: Postgres catalogs (schema: ${params.schema})
 * Generated by: oosync/src/codegen-schema.ts
 */\n\n`;
}

function toCamelCase(value: string): string {
  return value.replace(/_([a-z0-9])/g, (_, c: string) => c.toUpperCase());
}

function safeIdentifier(raw: string): string {
  const candidate = toCamelCase(raw);
  if (/^[a-zA-Z_$][\w$]*$/.test(candidate)) return candidate;
  return `t_${candidate.replace(/[^\w$]/g, "_")}`;
}

function normalizeType(params: { dataType: string; udtName: string }): string {
  const dt = params.dataType.toLowerCase();
  const udt = params.udtName.toLowerCase();

  if (dt === "user-defined") return udt; // enums and domains
  if (dt.startsWith("timestamp")) return "timestamp";
  if (dt === "timestamp with time zone") return "timestamptz";
  if (dt === "uuid") return "uuid";
  if (dt === "boolean") return "boolean";
  if (dt === "json" || dt === "jsonb") return dt;
  if (dt === "date") return "date";
  if (dt === "time without time zone") return "time";
  if (dt === "time with time zone") return "timetz";

  // numbers
  if (dt === "integer" || dt === "smallint" || dt === "bigint") return "int";
  if (dt === "real" || dt === "double precision") return "real";
  if (dt === "numeric" || dt === "decimal") return "numeric";

  // text-ish
  if (
    dt === "text" ||
    dt === "character varying" ||
    dt === "character" ||
    dt === "citext"
  ) {
    return "text";
  }

  return dt;
}

function sqliteBuilderForPgType(pgType: string): "text" | "integer" | "real" {
  switch (pgType) {
    case "uuid":
    case "timestamp":
    case "timestamptz":
    case "date":
    case "time":
    case "timetz":
    case "json":
    case "jsonb":
    case "text":
      return "text";
    case "boolean":
    case "int":
      return "integer";
    case "real":
    case "numeric":
      return "real";
    default:
      // enums and other user-defined types: store as TEXT
      return "text";
  }
}

function isKnownPgType(pgType: string): boolean {
  return new Set([
    "uuid",
    "timestamp",
    "timestamptz",
    "date",
    "time",
    "timetz",
    "json",
    "jsonb",
    "text",
    "boolean",
    "int",
    "real",
    "numeric",
  ]).has(pgType);
}

function parsePgDefault(params: {
  pgType: string;
  columnDefault: string | null;
}):
  | { kind: "default"; value: string }
  | { kind: "$defaultFn"; value: string }
  | null {
  const def = params.columnDefault;
  if (!def) return null;

  const trimmed = def.trim();

  // UUID defaults
  if (
    params.pgType === "uuid" &&
    /(gen_random_uuid\(\)|uuid_generate_v4\(\))/i.test(trimmed)
  ) {
    return { kind: "$defaultFn", value: "() => generateId()" };
  }

  // timestamp defaults
  if (
    (params.pgType === "timestamp" || params.pgType === "timestamptz") &&
    /^(now\(\)|current_timestamp)$/i.test(trimmed)
  ) {
    return { kind: "$defaultFn", value: "() => new Date().toISOString()" };
  }

  // boolean constants (often: false / 'false'::boolean)
  if (params.pgType === "boolean") {
    if (/^false(\b|::)/i.test(trimmed) || /^'false'::/i.test(trimmed)) {
      return { kind: "default", value: "0" };
    }
    if (/^true(\b|::)/i.test(trimmed) || /^'true'::/i.test(trimmed)) {
      return { kind: "default", value: "1" };
    }
    if (/^'f'::/i.test(trimmed)) return { kind: "default", value: "0" };
    if (/^'t'::/i.test(trimmed)) return { kind: "default", value: "1" };
  }

  // numeric constants with optional casts
  if (
    params.pgType === "int" ||
    params.pgType === "real" ||
    params.pgType === "numeric"
  ) {
    const m = trimmed.match(/^(-?\d+(?:\.\d+)?)(?:(?:::.*)|\b)?$/);
    if (m) return { kind: "default", value: m[1] };
  }

  // string literal constants with casts (e.g. 'recall'::text)
  if (params.pgType === "text" || params.pgType === "uuid") {
    const m = trimmed.match(/^'(.*)'(?:::.*)?$/);
    if (m) {
      const unescaped = m[1].replace(/''/g, "'");
      return { kind: "default", value: JSON.stringify(unescaped) };
    }
  }

  // Unknown/defaults we don't confidently map: skip.
  return null;
}

function parseIndexKeyToColumnName(keydef: string): string | null {
  // Typical outputs: "col", "col DESC", "col" COLLATE "C"
  const m = keydef.trim().match(/^"?([a-zA-Z_][\w$]*)"?/);
  if (!m) return null;
  return m[1];
}

function stableSort<T>(items: T[], key: (item: T) => string): T[] {
  return [...items].sort((a, b) => key(a).localeCompare(key(b)));
}

function resolveConfigPath(params: { cliPath: string | null }): string | null {
  if (params.cliPath) return params.cliPath;
  const envPath = process.env.OOSYNC_CODEGEN_CONFIG;
  if (envPath) return envPath;

  const defaultPath = path.join(process.cwd(), "oosync.codegen.config.json");
  if (fs.existsSync(defaultPath)) return defaultPath;

  return null;
}

function loadCodegenConfig(configPath: string | null): ICodegenConfigFile {
  if (!configPath) return {};
  const abs = path.isAbsolute(configPath)
    ? configPath
    : path.join(process.cwd(), configPath);
  const raw = fs.readFileSync(abs, "utf8");
  const parsed: unknown = JSON.parse(raw);
  if (typeof parsed !== "object" || parsed === null) {
    throw new Error(`Invalid config file (expected object): ${abs}`);
  }
  return parsed as ICodegenConfigFile;
}

function buildTableMetaTs(params: {
  schema: string;
  columns: IColumnRow[];
  primaryKeys: IConstraintColumnRow[];
  uniqueConstraints: IConstraintColumnRow[];
  strict: boolean;
  syncableTables: string[];
  tableRegistryCore: Record<string, ITableMetaCore>;
}): string {
  const colsByTable = groupByKey(params.columns, (c) => c.table_name);
  const uniqueByTableConstraint = groupByKey(
    params.uniqueConstraints,
    (r) => `${r.table_name}::${r.constraint_name}`
  );

  const availableTables = new Set(colsByTable.keys());
  const missingTables = params.syncableTables.filter(
    (t) => !availableTables.has(t)
  );
  if (params.strict && missingTables.length > 0) {
    throw new Error(
      `Missing tables for sync metadata: ${missingTables.join(", ")}`
    );
  }

  const lines: string[] = [];
  lines.push(createTableMetaHeader({ schema: params.schema }));

  lines.push("export interface TableMetaCore {");
  lines.push("  primaryKey: string | string[];");
  lines.push("  uniqueKeys: string[] | null;");
  lines.push("  timestamps: string[];");
  lines.push("  booleanColumns: string[];");
  lines.push("  supportsIncremental: boolean;");
  lines.push("  hasDeletedFlag: boolean;");
  lines.push("}");
  lines.push("");

  lines.push("export const SYNCABLE_TABLES = [");
  for (const t of params.syncableTables) {
    lines.push(`  ${JSON.stringify(t)},`);
  }
  lines.push("] as const;");
  lines.push("");
  lines.push(
    "export type SyncableTableName = (typeof SYNCABLE_TABLES)[number];"
  );
  lines.push("");

  lines.push(
    "export const TABLE_REGISTRY_CORE: Record<SyncableTableName, TableMetaCore> = {"
  );

  for (const tableName of params.syncableTables) {
    const core = params.tableRegistryCore[tableName];
    if (!core) {
      throw new Error(`Missing tableRegistryCore entry for ${tableName}`);
    }
    const tableCols = (colsByTable.get(tableName) ?? []).slice();
    const colSet = new Set(tableCols.map((c) => c.column_name));

    if (params.strict) {
      const pkCols = Array.isArray(core.primaryKey)
        ? core.primaryKey
        : [core.primaryKey];
      for (const c of pkCols) {
        if (!colSet.has(c)) {
          throw new Error(`Primary key column not found: ${tableName}.${c}`);
        }
      }
      if (core.uniqueKeys) {
        for (const c of core.uniqueKeys) {
          if (!colSet.has(c)) {
            throw new Error(`Unique key column not found: ${tableName}.${c}`);
          }
        }
      }
      for (const c of core.timestamps) {
        if (!colSet.has(c)) {
          throw new Error(`Timestamp column not found: ${tableName}.${c}`);
        }
      }
      for (const c of core.booleanColumns) {
        if (!colSet.has(c)) {
          throw new Error(`Boolean column not found: ${tableName}.${c}`);
        }
      }

      // If supportsIncremental is true, enforce presence of last_modified_at.
      if (core.supportsIncremental && !colSet.has("last_modified_at")) {
        throw new Error(
          `supportsIncremental=true but last_modified_at missing: ${tableName}.last_modified_at`
        );
      }

      // Validate uniqueKeys correspond to a UNIQUE constraint (or PK for composite).
      if (core.uniqueKeys) {
        const isCompositePk = Array.isArray(core.primaryKey);
        const uniqueCandidates = [...uniqueByTableConstraint.entries()]
          .filter(([k]) => k.startsWith(`${tableName}::`))
          .map(([, rows]) =>
            [...rows]
              .sort((a, b) => a.position - b.position)
              .map((r) => r.column_name)
          );
        const matchesUnique = uniqueCandidates.some(
          (cols) =>
            cols.length === core.uniqueKeys!.length &&
            cols.every((c, i) => c === core.uniqueKeys![i])
        );

        if (!matchesUnique) {
          // A composite PK is a valid conflict target.
          if (
            !isCompositePk ||
            core.uniqueKeys.length !== core.primaryKey.length ||
            !core.uniqueKeys.every(
              (c: string, i: number) => c === (core.primaryKey as string[])[i]
            )
          ) {
            throw new Error(
              `uniqueKeys for ${tableName} does not match any UNIQUE constraint: [${core.uniqueKeys.join(", ")}]`
            );
          }
        }
      }
    }

    const pkLiteral = Array.isArray(core.primaryKey)
      ? `[${core.primaryKey.map((c: string) => JSON.stringify(c)).join(", ")}]`
      : JSON.stringify(core.primaryKey);
    const uniqueLiteral = core.uniqueKeys
      ? `[${core.uniqueKeys.map((c: string) => JSON.stringify(c)).join(", ")}]`
      : "null";
    const tsLiteral = `[${core.timestamps
      .map((c: string) => JSON.stringify(c))
      .join(", ")}]`;
    const boolLiteral = `[${core.booleanColumns
      .map((c: string) => JSON.stringify(c))
      .join(", ")}]`;

    lines.push(`  ${JSON.stringify(tableName)}: {`);
    lines.push(`    primaryKey: ${pkLiteral},`);
    lines.push(`    uniqueKeys: ${uniqueLiteral},`);
    lines.push(`    timestamps: ${tsLiteral},`);
    lines.push(`    booleanColumns: ${boolLiteral},`);
    lines.push(
      `    supportsIncremental: ${core.supportsIncremental ? "true" : "false"},`
    );
    lines.push(
      `    hasDeletedFlag: ${core.hasDeletedFlag ? "true" : "false"},`
    );
    lines.push("  },");
  }

  lines.push("};");
  lines.push("");

  return lines.join("\n").replace(/\n{3,}/g, "\n\n");
}

async function introspect(params: {
  databaseUrl: string;
  schema: string;
}): Promise<{
  columns: IColumnRow[];
  primaryKeys: IConstraintColumnRow[];
  uniqueConstraints: IConstraintColumnRow[];
  indexes: IIndexKeyRow[];
  foreignKeys: IForeignKeyRow[];
}> {
  const sql = postgres(params.databaseUrl, {
    prepare: false,
    max: 1,
  });

  try {
    const columns = await sql<IColumnRow[]>`
      select
        c.table_name,
        c.column_name,
        c.data_type,
        c.udt_name,
        c.is_nullable,
        c.column_default,
        c.ordinal_position
      from information_schema.columns c
      join information_schema.tables t
        on t.table_schema = c.table_schema
        and t.table_name = c.table_name
      where c.table_schema = ${params.schema}
        and t.table_type = 'BASE TABLE'
      order by c.table_name, c.ordinal_position;
    `;

    const primaryKeys = await sql<IConstraintColumnRow[]>`
      select
        cl.relname as table_name,
        con.conname as constraint_name,
        a.attname as column_name,
        k.ordinality as position
      from pg_constraint con
      join pg_class cl on cl.oid = con.conrelid
      join pg_namespace n on n.oid = cl.relnamespace
      join unnest(con.conkey) with ordinality as k(attnum, ordinality) on true
      join pg_attribute a on a.attrelid = con.conrelid and a.attnum = k.attnum
      where con.contype = 'p'
        and n.nspname = ${params.schema}
      order by cl.relname, con.conname, k.ordinality;
    `;

    const uniqueConstraints = await sql<IConstraintColumnRow[]>`
      select
        cl.relname as table_name,
        con.conname as constraint_name,
        a.attname as column_name,
        k.ordinality as position
      from pg_constraint con
      join pg_class cl on cl.oid = con.conrelid
      join pg_namespace n on n.oid = cl.relnamespace
      join unnest(con.conkey) with ordinality as k(attnum, ordinality) on true
      join pg_attribute a on a.attrelid = con.conrelid and a.attnum = k.attnum
      where con.contype = 'u'
        and n.nspname = ${params.schema}
      order by cl.relname, con.conname, k.ordinality;
    `;

    const indexes = await sql<IIndexKeyRow[]>`
      select
        t.relname as table_name,
        ix.relname as index_name,
        pg_get_indexdef(i.indexrelid, k.n, true) as keydef,
        k.n as position
      from pg_index i
      join pg_class t on t.oid = i.indrelid
      join pg_namespace n on n.oid = t.relnamespace
      join pg_class ix on ix.oid = i.indexrelid
      join generate_series(1, i.indnkeyatts) as k(n) on true
      where n.nspname = ${params.schema}
        and i.indisprimary = false
        and i.indisunique = false
      order by t.relname, ix.relname, k.n;
    `;

    const foreignKeys = await sql<IForeignKeyRow[]>`
      select
        cl.relname as table_name,
        con.conname as constraint_name,
        src.attname as column_name,
        refcl.relname as ref_table_name,
        refatt.attname as ref_column_name,
        srccols.ordinality as position
      from pg_constraint con
      join pg_class cl on cl.oid = con.conrelid
      join pg_namespace n on n.oid = cl.relnamespace
      join pg_class refcl on refcl.oid = con.confrelid
      join unnest(con.conkey) with ordinality as srccols(attnum, ordinality) on true
      join pg_attribute src on src.attrelid = con.conrelid and src.attnum = srccols.attnum
      join unnest(con.confkey) with ordinality as refcols(attnum, ordinality) on refcols.ordinality = srccols.ordinality
      join pg_attribute refatt on refatt.attrelid = con.confrelid and refatt.attnum = refcols.attnum
      where con.contype = 'f'
        and n.nspname = ${params.schema}
      order by cl.relname, con.conname, srccols.ordinality;
    `;

    return {
      columns,
      primaryKeys,
      uniqueConstraints,
      indexes,
      foreignKeys,
    };
  } finally {
    await sql.end({ timeout: 5 });
  }
}

function groupByKey<T>(items: T[], key: (item: T) => string): Map<string, T[]> {
  const map = new Map<string, T[]>();
  for (const item of items) {
    const k = key(item);
    const arr = map.get(k);
    if (arr) arr.push(item);
    else map.set(k, [item]);
  }
  return map;
}

function buildSchemaTs(params: {
  schema: string;
  columns: IColumnRow[];
  primaryKeys: IConstraintColumnRow[];
  uniqueConstraints: IConstraintColumnRow[];
  indexes: IIndexKeyRow[];
  foreignKeys: IForeignKeyRow[];
  strict: boolean;
}): string {
  const ignoredTables = new Set<string>([
    "schema_migrations",
    "drizzle_migrations",
  ]);

  const colsByTable = groupByKey(params.columns, (c) => c.table_name);

  const pkByTable = groupByKey(params.primaryKeys, (r) => r.table_name);
  const uniqueByTableConstraint = groupByKey(
    params.uniqueConstraints,
    (r) => `${r.table_name}::${r.constraint_name}`
  );
  const idxByTableIndex = groupByKey(
    params.indexes,
    (r) => `${r.table_name}::${r.index_name}`
  );
  const fkByTableConstraint = groupByKey(
    params.foreignKeys,
    (r) => `${r.table_name}::${r.constraint_name}`
  );

  const tables = stableSort([...colsByTable.keys()], (t) => t).filter(
    (t) => !ignoredTables.has(t)
  );

  // Deterministic, globally stable table identifiers.
  const tableIdentByName = new Map<string, string>();
  const usedIdents = new Set<string>();
  for (const tableName of tables) {
    let ident = safeIdentifier(tableName);
    while (usedIdents.has(ident)) ident = `${ident}_`; // deterministic collision resolver
    usedIdents.add(ident);
    tableIdentByName.set(tableName, ident);
  }

  const lines: string[] = [];
  lines.push(createHeader({ schema: params.schema }));

  const sqliteCoreImport =
    'import { index, integer, primaryKey, real, sqliteTable, text, uniqueIndex } from "drizzle-orm/sqlite-core";';
  lines.push(sqliteCoreImport);

  // We may or may not need generateId depending on defaults.
  let needsGenerateId = false;

  lines.push('import { sqliteSyncColumns } from "./sync-columns";');
  lines.push("");

  // Precompute FK mapping per (table,col)
  const fkByTableCol = new Map<string, IForeignKeyRow>();
  for (const [key, rows] of fkByTableConstraint.entries()) {
    if (rows.length !== 1) {
      if (params.strict) {
        throw new Error(
          `Unsupported composite foreign key: ${key} (${rows.length} columns). Use --lenient to skip.`
        );
      }
      continue;
    }
    const one = rows[0];
    fkByTableCol.set(`${one.table_name}::${one.column_name}`, one);
  }

  for (const tableName of tables) {
    const ident = tableIdentByName.get(tableName);
    if (!ident) continue;

    const tableColumns = (colsByTable.get(tableName) ?? []).slice();
    tableColumns.sort((a, b) => a.ordinal_position - b.ordinal_position);

    const pkCols = (pkByTable.get(tableName) ?? []).slice();
    pkCols.sort((a, b) => a.position - b.position);

    const hasSyncCols =
      tableColumns.some((c) => c.column_name === "sync_version") &&
      tableColumns.some((c) => c.column_name === "last_modified_at") &&
      tableColumns.some((c) => c.column_name === "device_id");

    const columnsToEmit = hasSyncCols
      ? tableColumns.filter(
          (c) =>
            c.column_name !== "sync_version" &&
            c.column_name !== "last_modified_at" &&
            c.column_name !== "device_id"
        )
      : tableColumns;

    // Column pk lookup
    const pkSet = new Set(pkCols.map((r) => r.column_name));
    const isSinglePk = pkCols.length === 1;

    lines.push(`export const ${ident} = sqliteTable("${tableName}", {`);

    for (const col of columnsToEmit) {
      const propName = safeIdentifier(col.column_name);
      const pgType = normalizeType({
        dataType: col.data_type,
        udtName: col.udt_name,
      });

      // Strict type safety: only allow explicit mappings (plus enums/domains stored as TEXT).
      if (params.strict && col.data_type.toLowerCase() !== "user-defined") {
        if (!isKnownPgType(pgType)) {
          throw new Error(
            `Unmappable Postgres type for ${tableName}.${col.column_name}: data_type=${col.data_type} udt_name=${col.udt_name} (normalized=${pgType}).`
          );
        }
      }
      const builder = sqliteBuilderForPgType(pgType);

      const pieces: string[] = [`${builder}("${col.column_name}")`];

      if (col.is_nullable === "NO") pieces.push("notNull()");

      // Foreign key (single-column only)
      const fk = fkByTableCol.get(`${tableName}::${col.column_name}`);
      if (fk) {
        const refTableIdent = tableIdentByName.get(fk.ref_table_name);
        const refColProp = safeIdentifier(fk.ref_column_name);
        if (refTableIdent) {
          pieces.push(`references(() => ${refTableIdent}.${refColProp})`);
        }
      }

      // PK
      if (pkSet.has(col.column_name) && isSinglePk) {
        pieces.push("primaryKey()");
      }

      // Defaults
      const parsedDefault = parsePgDefault({
        pgType,
        columnDefault: col.column_default,
      });
      if (parsedDefault) {
        if (parsedDefault.kind === "default") {
          pieces.push(`default(${parsedDefault.value})`);
        } else {
          needsGenerateId =
            needsGenerateId || parsedDefault.value.includes("generateId");
          pieces.push(`$defaultFn(${parsedDefault.value})`);
        }
      } else if (params.strict && col.column_default) {
        // We saw a default but couldn't map it deterministically.
        throw new Error(
          `Unsupported default for ${tableName}.${col.column_name}: ${col.column_default}. Use --lenient to skip.`
        );
      }

      const chain = pieces.map((p, idx) => (idx === 0 ? p : `.${p}`)).join("");

      lines.push(`  ${propName}: ${chain},`);
    }

    if (hasSyncCols) {
      lines.push("  ...sqliteSyncColumns,");
    }

    lines.push("}");

    const configItems: string[] = [];

    // Composite PK
    if (pkCols.length > 1) {
      const pkProps = pkCols
        .map((r) => `t.${safeIdentifier(r.column_name)}`)
        .join(", ");
      configItems.push(`primaryKey({ columns: [${pkProps}] })`);
    }

    // Unique constraints
    const uniqueForTable = [...uniqueByTableConstraint.entries()]
      .filter(([k]) => k.startsWith(`${tableName}::`))
      .map(([, rows]) => rows);

    for (const rows of uniqueForTable) {
      const sorted = [...rows].sort((a, b) => a.position - b.position);
      const name = sorted[0]?.constraint_name;
      if (!name) continue;
      const cols = sorted
        .map((r) => `t.${safeIdentifier(r.column_name)}`)
        .join(", ");
      configItems.push(`uniqueIndex("${name}").on(${cols})`);
    }

    // Non-unique indexes
    const indexesForTable = [...idxByTableIndex.entries()]
      .filter(([k]) => k.startsWith(`${tableName}::`))
      .map(([, rows]) => rows);

    for (const rows of indexesForTable) {
      const sorted = [...rows].sort((a, b) => a.position - b.position);
      const indexName = sorted[0]?.index_name;
      if (!indexName) continue;

      const colRefs: string[] = [];
      for (const r of sorted) {
        const colName = parseIndexKeyToColumnName(r.keydef);
        if (!colName) {
          if (params.strict) {
            throw new Error(
              `Unsupported index key for ${tableName}.${indexName}: ${r.keydef}. Use --lenient to skip.`
            );
          }
          colRefs.length = 0;
          break;
        }
        colRefs.push(`t.${safeIdentifier(colName)}`);
      }
      if (colRefs.length === 0) continue;
      configItems.push(`index("${indexName}").on(${colRefs.join(", ")})`);
    }

    if (configItems.length > 0) {
      lines.push(", (t) => [");
      for (const item of configItems) {
        lines.push(`  ${item},`);
      }
      lines.push("]");
      lines.push(");");
    } else {
      lines.push(");");
    }

    lines.push("");
  }

  if (needsGenerateId) {
    lines.splice(2, 0, 'import { generateId } from "../src/lib/utils/uuid";');
  }

  return lines.join("\n").replace(/\n{3,}/g, "\n\n");
}

async function main(): Promise<void> {
  const args = parseArgs(process.argv.slice(2));
  const configPath = resolveConfigPath({ cliPath: args.configPath });
  const config = loadCodegenConfig(configPath);

  const outputSchemaFile = config.outputs?.sqliteSchemaFile
    ? path.isAbsolute(config.outputs.sqliteSchemaFile)
      ? config.outputs.sqliteSchemaFile
      : path.join(process.cwd(), config.outputs.sqliteSchemaFile)
    : DEFAULT_OUTPUT_SQLITE_SCHEMA_FILE;

  const outputTableMetaFile = config.outputs?.tableMetaFile
    ? path.isAbsolute(config.outputs.tableMetaFile)
      ? config.outputs.tableMetaFile
      : path.join(process.cwd(), config.outputs.tableMetaFile)
    : DEFAULT_OUTPUT_TABLE_META_FILE;

  const { columns, primaryKeys, uniqueConstraints, indexes, foreignKeys } =
    await introspect({ databaseUrl: args.databaseUrl, schema: args.schema });

  const next = buildSchemaTs({
    schema: args.schema,
    columns,
    primaryKeys,
    uniqueConstraints,
    indexes,
    foreignKeys,
    strict: args.strict,
  });

  const hasTableMetaConfig =
    Array.isArray(config.tableMeta?.syncableTables) &&
    config.tableMeta?.syncableTables.length > 0;

  const nextTableMeta = hasTableMetaConfig
    ? (() => {
        const syncableTables = [...(config.tableMeta?.syncableTables ?? [])];
        const tableRegistryCore = config.tableMeta?.tableRegistryCore ?? {};
        if (Object.keys(tableRegistryCore).length === 0) {
          throw new Error(
            "tableMeta.syncableTables provided, but tableMeta.tableRegistryCore is missing/empty"
          );
        }

        return buildTableMetaTs({
          schema: args.schema,
          columns,
          primaryKeys,
          uniqueConstraints,
          strict: args.strict,
          syncableTables,
          tableRegistryCore,
        });
      })()
    : null;

  if (args.check) {
    const current = fs.existsSync(outputSchemaFile)
      ? fs.readFileSync(outputSchemaFile, "utf8")
      : "";
    if (current !== next) {
      throw new Error(
        `SQLite schema is out of date. Run: npm run codegen:schema (output: ${outputSchemaFile})`
      );
    }

    if (nextTableMeta !== null) {
      const currentMeta = fs.existsSync(outputTableMetaFile)
        ? fs.readFileSync(outputTableMetaFile, "utf8")
        : "";
      if (currentMeta !== nextTableMeta) {
        throw new Error(
          `Shared table metadata is out of date. Run: npm run codegen:schema (output: ${outputTableMetaFile})`
        );
      }
    }
    // eslint-disable-next-line no-console
    console.log(
      "✅ SQLite schema + shared table metadata are up to date (via Postgres introspection)."
    );
    return;
  }

  fs.writeFileSync(outputSchemaFile, next, "utf8");
  if (nextTableMeta !== null) {
    fs.writeFileSync(outputTableMetaFile, nextTableMeta, "utf8");
  }
  // eslint-disable-next-line no-console
  console.log(
    nextTableMeta === null
      ? `✅ Wrote ${path.relative(process.cwd(), outputSchemaFile)}`
      : `✅ Wrote ${path.relative(process.cwd(), outputSchemaFile)} and ${path.relative(
          process.cwd(),
          outputTableMetaFile
        )}`
  );
}

main().catch((err) => {
  // eslint-disable-next-line no-console
  console.error(err);
  process.exit(1);
});
